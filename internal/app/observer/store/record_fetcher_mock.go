package store

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// RecordFetcherMock implements RecordFetcher
type RecordFetcherMock struct {
	t minimock.Tester

	funcCalledRequests          func(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error)
	inspectFuncCalledRequests   func(ctx context.Context, reqID insolar.ID)
	afterCalledRequestsCounter  uint64
	beforeCalledRequestsCounter uint64
	CalledRequestsMock          mRecordFetcherMockCalledRequests

	funcRequest          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncRequest   func(ctx context.Context, reqID insolar.ID)
	afterRequestCounter  uint64
	beforeRequestCounter uint64
	RequestMock          mRecordFetcherMockRequest

	funcResult          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncResult   func(ctx context.Context, reqID insolar.ID)
	afterResultCounter  uint64
	beforeResultCounter uint64
	ResultMock          mRecordFetcherMockResult

	funcSideEffect          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncSideEffect   func(ctx context.Context, reqID insolar.ID)
	afterSideEffectCounter  uint64
	beforeSideEffectCounter uint64
	SideEffectMock          mRecordFetcherMockSideEffect
}

// NewRecordFetcherMock returns a mock for RecordFetcher
func NewRecordFetcherMock(t minimock.Tester) *RecordFetcherMock {
	m := &RecordFetcherMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CalledRequestsMock = mRecordFetcherMockCalledRequests{mock: m}
	m.CalledRequestsMock.callArgs = []*RecordFetcherMockCalledRequestsParams{}

	m.RequestMock = mRecordFetcherMockRequest{mock: m}
	m.RequestMock.callArgs = []*RecordFetcherMockRequestParams{}

	m.ResultMock = mRecordFetcherMockResult{mock: m}
	m.ResultMock.callArgs = []*RecordFetcherMockResultParams{}

	m.SideEffectMock = mRecordFetcherMockSideEffect{mock: m}
	m.SideEffectMock.callArgs = []*RecordFetcherMockSideEffectParams{}

	return m
}

type mRecordFetcherMockCalledRequests struct {
	mock               *RecordFetcherMock
	defaultExpectation *RecordFetcherMockCalledRequestsExpectation
	expectations       []*RecordFetcherMockCalledRequestsExpectation

	callArgs []*RecordFetcherMockCalledRequestsParams
	mutex    sync.RWMutex
}

// RecordFetcherMockCalledRequestsExpectation specifies expectation struct of the RecordFetcher.CalledRequests
type RecordFetcherMockCalledRequestsExpectation struct {
	mock    *RecordFetcherMock
	params  *RecordFetcherMockCalledRequestsParams
	results *RecordFetcherMockCalledRequestsResults
	Counter uint64
}

// RecordFetcherMockCalledRequestsParams contains parameters of the RecordFetcher.CalledRequests
type RecordFetcherMockCalledRequestsParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordFetcherMockCalledRequestsResults contains results of the RecordFetcher.CalledRequests
type RecordFetcherMockCalledRequestsResults struct {
	ma1 []record.Material
	err error
}

// Expect sets up expected params for RecordFetcher.CalledRequests
func (mmCalledRequests *mRecordFetcherMockCalledRequests) Expect(ctx context.Context, reqID insolar.ID) *mRecordFetcherMockCalledRequests {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordFetcherMock.CalledRequests mock is already set by Set")
	}

	if mmCalledRequests.defaultExpectation == nil {
		mmCalledRequests.defaultExpectation = &RecordFetcherMockCalledRequestsExpectation{}
	}

	mmCalledRequests.defaultExpectation.params = &RecordFetcherMockCalledRequestsParams{ctx, reqID}
	for _, e := range mmCalledRequests.expectations {
		if minimock.Equal(e.params, mmCalledRequests.defaultExpectation.params) {
			mmCalledRequests.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCalledRequests.defaultExpectation.params)
		}
	}

	return mmCalledRequests
}

// Inspect accepts an inspector function that has same arguments as the RecordFetcher.CalledRequests
func (mmCalledRequests *mRecordFetcherMockCalledRequests) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordFetcherMockCalledRequests {
	if mmCalledRequests.mock.inspectFuncCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("Inspect function is already set for RecordFetcherMock.CalledRequests")
	}

	mmCalledRequests.mock.inspectFuncCalledRequests = f

	return mmCalledRequests
}

// Return sets up results that will be returned by RecordFetcher.CalledRequests
func (mmCalledRequests *mRecordFetcherMockCalledRequests) Return(ma1 []record.Material, err error) *RecordFetcherMock {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordFetcherMock.CalledRequests mock is already set by Set")
	}

	if mmCalledRequests.defaultExpectation == nil {
		mmCalledRequests.defaultExpectation = &RecordFetcherMockCalledRequestsExpectation{mock: mmCalledRequests.mock}
	}
	mmCalledRequests.defaultExpectation.results = &RecordFetcherMockCalledRequestsResults{ma1, err}
	return mmCalledRequests.mock
}

//Set uses given function f to mock the RecordFetcher.CalledRequests method
func (mmCalledRequests *mRecordFetcherMockCalledRequests) Set(f func(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error)) *RecordFetcherMock {
	if mmCalledRequests.defaultExpectation != nil {
		mmCalledRequests.mock.t.Fatalf("Default expectation is already set for the RecordFetcher.CalledRequests method")
	}

	if len(mmCalledRequests.expectations) > 0 {
		mmCalledRequests.mock.t.Fatalf("Some expectations are already set for the RecordFetcher.CalledRequests method")
	}

	mmCalledRequests.mock.funcCalledRequests = f
	return mmCalledRequests.mock
}

// When sets expectation for the RecordFetcher.CalledRequests which will trigger the result defined by the following
// Then helper
func (mmCalledRequests *mRecordFetcherMockCalledRequests) When(ctx context.Context, reqID insolar.ID) *RecordFetcherMockCalledRequestsExpectation {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordFetcherMock.CalledRequests mock is already set by Set")
	}

	expectation := &RecordFetcherMockCalledRequestsExpectation{
		mock:   mmCalledRequests.mock,
		params: &RecordFetcherMockCalledRequestsParams{ctx, reqID},
	}
	mmCalledRequests.expectations = append(mmCalledRequests.expectations, expectation)
	return expectation
}

// Then sets up RecordFetcher.CalledRequests return parameters for the expectation previously defined by the When method
func (e *RecordFetcherMockCalledRequestsExpectation) Then(ma1 []record.Material, err error) *RecordFetcherMock {
	e.results = &RecordFetcherMockCalledRequestsResults{ma1, err}
	return e.mock
}

// CalledRequests implements RecordFetcher
func (mmCalledRequests *RecordFetcherMock) CalledRequests(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error) {
	mm_atomic.AddUint64(&mmCalledRequests.beforeCalledRequestsCounter, 1)
	defer mm_atomic.AddUint64(&mmCalledRequests.afterCalledRequestsCounter, 1)

	if mmCalledRequests.inspectFuncCalledRequests != nil {
		mmCalledRequests.inspectFuncCalledRequests(ctx, reqID)
	}

	params := &RecordFetcherMockCalledRequestsParams{ctx, reqID}

	// Record call args
	mmCalledRequests.CalledRequestsMock.mutex.Lock()
	mmCalledRequests.CalledRequestsMock.callArgs = append(mmCalledRequests.CalledRequestsMock.callArgs, params)
	mmCalledRequests.CalledRequestsMock.mutex.Unlock()

	for _, e := range mmCalledRequests.CalledRequestsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmCalledRequests.CalledRequestsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCalledRequests.CalledRequestsMock.defaultExpectation.Counter, 1)
		want := mmCalledRequests.CalledRequestsMock.defaultExpectation.params
		got := RecordFetcherMockCalledRequestsParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmCalledRequests.t.Errorf("RecordFetcherMock.CalledRequests got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCalledRequests.CalledRequestsMock.defaultExpectation.results
		if results == nil {
			mmCalledRequests.t.Fatal("No results are set for the RecordFetcherMock.CalledRequests")
		}
		return (*results).ma1, (*results).err
	}
	if mmCalledRequests.funcCalledRequests != nil {
		return mmCalledRequests.funcCalledRequests(ctx, reqID)
	}
	mmCalledRequests.t.Fatalf("Unexpected call to RecordFetcherMock.CalledRequests. %v %v", ctx, reqID)
	return
}

// CalledRequestsAfterCounter returns a count of finished RecordFetcherMock.CalledRequests invocations
func (mmCalledRequests *RecordFetcherMock) CalledRequestsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalledRequests.afterCalledRequestsCounter)
}

// CalledRequestsBeforeCounter returns a count of RecordFetcherMock.CalledRequests invocations
func (mmCalledRequests *RecordFetcherMock) CalledRequestsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalledRequests.beforeCalledRequestsCounter)
}

// Calls returns a list of arguments used in each call to RecordFetcherMock.CalledRequests.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCalledRequests *mRecordFetcherMockCalledRequests) Calls() []*RecordFetcherMockCalledRequestsParams {
	mmCalledRequests.mutex.RLock()

	argCopy := make([]*RecordFetcherMockCalledRequestsParams, len(mmCalledRequests.callArgs))
	copy(argCopy, mmCalledRequests.callArgs)

	mmCalledRequests.mutex.RUnlock()

	return argCopy
}

// MinimockCalledRequestsDone returns true if the count of the CalledRequests invocations corresponds
// the number of defined expectations
func (m *RecordFetcherMock) MinimockCalledRequestsDone() bool {
	for _, e := range m.CalledRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalledRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalledRequests != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCalledRequestsInspect logs each unmet expectation
func (m *RecordFetcherMock) MinimockCalledRequestsInspect() {
	for _, e := range m.CalledRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordFetcherMock.CalledRequests with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalledRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		if m.CalledRequestsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordFetcherMock.CalledRequests")
		} else {
			m.t.Errorf("Expected call to RecordFetcherMock.CalledRequests with params: %#v", *m.CalledRequestsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalledRequests != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		m.t.Error("Expected call to RecordFetcherMock.CalledRequests")
	}
}

type mRecordFetcherMockRequest struct {
	mock               *RecordFetcherMock
	defaultExpectation *RecordFetcherMockRequestExpectation
	expectations       []*RecordFetcherMockRequestExpectation

	callArgs []*RecordFetcherMockRequestParams
	mutex    sync.RWMutex
}

// RecordFetcherMockRequestExpectation specifies expectation struct of the RecordFetcher.Request
type RecordFetcherMockRequestExpectation struct {
	mock    *RecordFetcherMock
	params  *RecordFetcherMockRequestParams
	results *RecordFetcherMockRequestResults
	Counter uint64
}

// RecordFetcherMockRequestParams contains parameters of the RecordFetcher.Request
type RecordFetcherMockRequestParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordFetcherMockRequestResults contains results of the RecordFetcher.Request
type RecordFetcherMockRequestResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordFetcher.Request
func (mmRequest *mRecordFetcherMockRequest) Expect(ctx context.Context, reqID insolar.ID) *mRecordFetcherMockRequest {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordFetcherMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &RecordFetcherMockRequestExpectation{}
	}

	mmRequest.defaultExpectation.params = &RecordFetcherMockRequestParams{ctx, reqID}
	for _, e := range mmRequest.expectations {
		if minimock.Equal(e.params, mmRequest.defaultExpectation.params) {
			mmRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequest.defaultExpectation.params)
		}
	}

	return mmRequest
}

// Inspect accepts an inspector function that has same arguments as the RecordFetcher.Request
func (mmRequest *mRecordFetcherMockRequest) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordFetcherMockRequest {
	if mmRequest.mock.inspectFuncRequest != nil {
		mmRequest.mock.t.Fatalf("Inspect function is already set for RecordFetcherMock.Request")
	}

	mmRequest.mock.inspectFuncRequest = f

	return mmRequest
}

// Return sets up results that will be returned by RecordFetcher.Request
func (mmRequest *mRecordFetcherMockRequest) Return(m1 record.Material, err error) *RecordFetcherMock {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordFetcherMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &RecordFetcherMockRequestExpectation{mock: mmRequest.mock}
	}
	mmRequest.defaultExpectation.results = &RecordFetcherMockRequestResults{m1, err}
	return mmRequest.mock
}

//Set uses given function f to mock the RecordFetcher.Request method
func (mmRequest *mRecordFetcherMockRequest) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordFetcherMock {
	if mmRequest.defaultExpectation != nil {
		mmRequest.mock.t.Fatalf("Default expectation is already set for the RecordFetcher.Request method")
	}

	if len(mmRequest.expectations) > 0 {
		mmRequest.mock.t.Fatalf("Some expectations are already set for the RecordFetcher.Request method")
	}

	mmRequest.mock.funcRequest = f
	return mmRequest.mock
}

// When sets expectation for the RecordFetcher.Request which will trigger the result defined by the following
// Then helper
func (mmRequest *mRecordFetcherMockRequest) When(ctx context.Context, reqID insolar.ID) *RecordFetcherMockRequestExpectation {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordFetcherMock.Request mock is already set by Set")
	}

	expectation := &RecordFetcherMockRequestExpectation{
		mock:   mmRequest.mock,
		params: &RecordFetcherMockRequestParams{ctx, reqID},
	}
	mmRequest.expectations = append(mmRequest.expectations, expectation)
	return expectation
}

// Then sets up RecordFetcher.Request return parameters for the expectation previously defined by the When method
func (e *RecordFetcherMockRequestExpectation) Then(m1 record.Material, err error) *RecordFetcherMock {
	e.results = &RecordFetcherMockRequestResults{m1, err}
	return e.mock
}

// Request implements RecordFetcher
func (mmRequest *RecordFetcherMock) Request(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmRequest.beforeRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRequest.afterRequestCounter, 1)

	if mmRequest.inspectFuncRequest != nil {
		mmRequest.inspectFuncRequest(ctx, reqID)
	}

	params := &RecordFetcherMockRequestParams{ctx, reqID}

	// Record call args
	mmRequest.RequestMock.mutex.Lock()
	mmRequest.RequestMock.callArgs = append(mmRequest.RequestMock.callArgs, params)
	mmRequest.RequestMock.mutex.Unlock()

	for _, e := range mmRequest.RequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmRequest.RequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequest.RequestMock.defaultExpectation.Counter, 1)
		want := mmRequest.RequestMock.defaultExpectation.params
		got := RecordFetcherMockRequestParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmRequest.t.Errorf("RecordFetcherMock.Request got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRequest.RequestMock.defaultExpectation.results
		if results == nil {
			mmRequest.t.Fatal("No results are set for the RecordFetcherMock.Request")
		}
		return (*results).m1, (*results).err
	}
	if mmRequest.funcRequest != nil {
		return mmRequest.funcRequest(ctx, reqID)
	}
	mmRequest.t.Fatalf("Unexpected call to RecordFetcherMock.Request. %v %v", ctx, reqID)
	return
}

// RequestAfterCounter returns a count of finished RecordFetcherMock.Request invocations
func (mmRequest *RecordFetcherMock) RequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.afterRequestCounter)
}

// RequestBeforeCounter returns a count of RecordFetcherMock.Request invocations
func (mmRequest *RecordFetcherMock) RequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.beforeRequestCounter)
}

// Calls returns a list of arguments used in each call to RecordFetcherMock.Request.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequest *mRecordFetcherMockRequest) Calls() []*RecordFetcherMockRequestParams {
	mmRequest.mutex.RLock()

	argCopy := make([]*RecordFetcherMockRequestParams, len(mmRequest.callArgs))
	copy(argCopy, mmRequest.callArgs)

	mmRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRequestDone returns true if the count of the Request invocations corresponds
// the number of defined expectations
func (m *RecordFetcherMock) MinimockRequestDone() bool {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestInspect logs each unmet expectation
func (m *RecordFetcherMock) MinimockRequestInspect() {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordFetcherMock.Request with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		if m.RequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordFetcherMock.Request")
		} else {
			m.t.Errorf("Expected call to RecordFetcherMock.Request with params: %#v", *m.RequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		m.t.Error("Expected call to RecordFetcherMock.Request")
	}
}

type mRecordFetcherMockResult struct {
	mock               *RecordFetcherMock
	defaultExpectation *RecordFetcherMockResultExpectation
	expectations       []*RecordFetcherMockResultExpectation

	callArgs []*RecordFetcherMockResultParams
	mutex    sync.RWMutex
}

// RecordFetcherMockResultExpectation specifies expectation struct of the RecordFetcher.Result
type RecordFetcherMockResultExpectation struct {
	mock    *RecordFetcherMock
	params  *RecordFetcherMockResultParams
	results *RecordFetcherMockResultResults
	Counter uint64
}

// RecordFetcherMockResultParams contains parameters of the RecordFetcher.Result
type RecordFetcherMockResultParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordFetcherMockResultResults contains results of the RecordFetcher.Result
type RecordFetcherMockResultResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordFetcher.Result
func (mmResult *mRecordFetcherMockResult) Expect(ctx context.Context, reqID insolar.ID) *mRecordFetcherMockResult {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordFetcherMock.Result mock is already set by Set")
	}

	if mmResult.defaultExpectation == nil {
		mmResult.defaultExpectation = &RecordFetcherMockResultExpectation{}
	}

	mmResult.defaultExpectation.params = &RecordFetcherMockResultParams{ctx, reqID}
	for _, e := range mmResult.expectations {
		if minimock.Equal(e.params, mmResult.defaultExpectation.params) {
			mmResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResult.defaultExpectation.params)
		}
	}

	return mmResult
}

// Inspect accepts an inspector function that has same arguments as the RecordFetcher.Result
func (mmResult *mRecordFetcherMockResult) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordFetcherMockResult {
	if mmResult.mock.inspectFuncResult != nil {
		mmResult.mock.t.Fatalf("Inspect function is already set for RecordFetcherMock.Result")
	}

	mmResult.mock.inspectFuncResult = f

	return mmResult
}

// Return sets up results that will be returned by RecordFetcher.Result
func (mmResult *mRecordFetcherMockResult) Return(m1 record.Material, err error) *RecordFetcherMock {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordFetcherMock.Result mock is already set by Set")
	}

	if mmResult.defaultExpectation == nil {
		mmResult.defaultExpectation = &RecordFetcherMockResultExpectation{mock: mmResult.mock}
	}
	mmResult.defaultExpectation.results = &RecordFetcherMockResultResults{m1, err}
	return mmResult.mock
}

//Set uses given function f to mock the RecordFetcher.Result method
func (mmResult *mRecordFetcherMockResult) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordFetcherMock {
	if mmResult.defaultExpectation != nil {
		mmResult.mock.t.Fatalf("Default expectation is already set for the RecordFetcher.Result method")
	}

	if len(mmResult.expectations) > 0 {
		mmResult.mock.t.Fatalf("Some expectations are already set for the RecordFetcher.Result method")
	}

	mmResult.mock.funcResult = f
	return mmResult.mock
}

// When sets expectation for the RecordFetcher.Result which will trigger the result defined by the following
// Then helper
func (mmResult *mRecordFetcherMockResult) When(ctx context.Context, reqID insolar.ID) *RecordFetcherMockResultExpectation {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordFetcherMock.Result mock is already set by Set")
	}

	expectation := &RecordFetcherMockResultExpectation{
		mock:   mmResult.mock,
		params: &RecordFetcherMockResultParams{ctx, reqID},
	}
	mmResult.expectations = append(mmResult.expectations, expectation)
	return expectation
}

// Then sets up RecordFetcher.Result return parameters for the expectation previously defined by the When method
func (e *RecordFetcherMockResultExpectation) Then(m1 record.Material, err error) *RecordFetcherMock {
	e.results = &RecordFetcherMockResultResults{m1, err}
	return e.mock
}

// Result implements RecordFetcher
func (mmResult *RecordFetcherMock) Result(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmResult.beforeResultCounter, 1)
	defer mm_atomic.AddUint64(&mmResult.afterResultCounter, 1)

	if mmResult.inspectFuncResult != nil {
		mmResult.inspectFuncResult(ctx, reqID)
	}

	params := &RecordFetcherMockResultParams{ctx, reqID}

	// Record call args
	mmResult.ResultMock.mutex.Lock()
	mmResult.ResultMock.callArgs = append(mmResult.ResultMock.callArgs, params)
	mmResult.ResultMock.mutex.Unlock()

	for _, e := range mmResult.ResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmResult.ResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResult.ResultMock.defaultExpectation.Counter, 1)
		want := mmResult.ResultMock.defaultExpectation.params
		got := RecordFetcherMockResultParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmResult.t.Errorf("RecordFetcherMock.Result got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmResult.ResultMock.defaultExpectation.results
		if results == nil {
			mmResult.t.Fatal("No results are set for the RecordFetcherMock.Result")
		}
		return (*results).m1, (*results).err
	}
	if mmResult.funcResult != nil {
		return mmResult.funcResult(ctx, reqID)
	}
	mmResult.t.Fatalf("Unexpected call to RecordFetcherMock.Result. %v %v", ctx, reqID)
	return
}

// ResultAfterCounter returns a count of finished RecordFetcherMock.Result invocations
func (mmResult *RecordFetcherMock) ResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResult.afterResultCounter)
}

// ResultBeforeCounter returns a count of RecordFetcherMock.Result invocations
func (mmResult *RecordFetcherMock) ResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResult.beforeResultCounter)
}

// Calls returns a list of arguments used in each call to RecordFetcherMock.Result.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResult *mRecordFetcherMockResult) Calls() []*RecordFetcherMockResultParams {
	mmResult.mutex.RLock()

	argCopy := make([]*RecordFetcherMockResultParams, len(mmResult.callArgs))
	copy(argCopy, mmResult.callArgs)

	mmResult.mutex.RUnlock()

	return argCopy
}

// MinimockResultDone returns true if the count of the Result invocations corresponds
// the number of defined expectations
func (m *RecordFetcherMock) MinimockResultDone() bool {
	for _, e := range m.ResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResult != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockResultInspect logs each unmet expectation
func (m *RecordFetcherMock) MinimockResultInspect() {
	for _, e := range m.ResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordFetcherMock.Result with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		if m.ResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordFetcherMock.Result")
		} else {
			m.t.Errorf("Expected call to RecordFetcherMock.Result with params: %#v", *m.ResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResult != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		m.t.Error("Expected call to RecordFetcherMock.Result")
	}
}

type mRecordFetcherMockSideEffect struct {
	mock               *RecordFetcherMock
	defaultExpectation *RecordFetcherMockSideEffectExpectation
	expectations       []*RecordFetcherMockSideEffectExpectation

	callArgs []*RecordFetcherMockSideEffectParams
	mutex    sync.RWMutex
}

// RecordFetcherMockSideEffectExpectation specifies expectation struct of the RecordFetcher.SideEffect
type RecordFetcherMockSideEffectExpectation struct {
	mock    *RecordFetcherMock
	params  *RecordFetcherMockSideEffectParams
	results *RecordFetcherMockSideEffectResults
	Counter uint64
}

// RecordFetcherMockSideEffectParams contains parameters of the RecordFetcher.SideEffect
type RecordFetcherMockSideEffectParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordFetcherMockSideEffectResults contains results of the RecordFetcher.SideEffect
type RecordFetcherMockSideEffectResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordFetcher.SideEffect
func (mmSideEffect *mRecordFetcherMockSideEffect) Expect(ctx context.Context, reqID insolar.ID) *mRecordFetcherMockSideEffect {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordFetcherMock.SideEffect mock is already set by Set")
	}

	if mmSideEffect.defaultExpectation == nil {
		mmSideEffect.defaultExpectation = &RecordFetcherMockSideEffectExpectation{}
	}

	mmSideEffect.defaultExpectation.params = &RecordFetcherMockSideEffectParams{ctx, reqID}
	for _, e := range mmSideEffect.expectations {
		if minimock.Equal(e.params, mmSideEffect.defaultExpectation.params) {
			mmSideEffect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSideEffect.defaultExpectation.params)
		}
	}

	return mmSideEffect
}

// Inspect accepts an inspector function that has same arguments as the RecordFetcher.SideEffect
func (mmSideEffect *mRecordFetcherMockSideEffect) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordFetcherMockSideEffect {
	if mmSideEffect.mock.inspectFuncSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("Inspect function is already set for RecordFetcherMock.SideEffect")
	}

	mmSideEffect.mock.inspectFuncSideEffect = f

	return mmSideEffect
}

// Return sets up results that will be returned by RecordFetcher.SideEffect
func (mmSideEffect *mRecordFetcherMockSideEffect) Return(m1 record.Material, err error) *RecordFetcherMock {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordFetcherMock.SideEffect mock is already set by Set")
	}

	if mmSideEffect.defaultExpectation == nil {
		mmSideEffect.defaultExpectation = &RecordFetcherMockSideEffectExpectation{mock: mmSideEffect.mock}
	}
	mmSideEffect.defaultExpectation.results = &RecordFetcherMockSideEffectResults{m1, err}
	return mmSideEffect.mock
}

//Set uses given function f to mock the RecordFetcher.SideEffect method
func (mmSideEffect *mRecordFetcherMockSideEffect) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordFetcherMock {
	if mmSideEffect.defaultExpectation != nil {
		mmSideEffect.mock.t.Fatalf("Default expectation is already set for the RecordFetcher.SideEffect method")
	}

	if len(mmSideEffect.expectations) > 0 {
		mmSideEffect.mock.t.Fatalf("Some expectations are already set for the RecordFetcher.SideEffect method")
	}

	mmSideEffect.mock.funcSideEffect = f
	return mmSideEffect.mock
}

// When sets expectation for the RecordFetcher.SideEffect which will trigger the result defined by the following
// Then helper
func (mmSideEffect *mRecordFetcherMockSideEffect) When(ctx context.Context, reqID insolar.ID) *RecordFetcherMockSideEffectExpectation {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordFetcherMock.SideEffect mock is already set by Set")
	}

	expectation := &RecordFetcherMockSideEffectExpectation{
		mock:   mmSideEffect.mock,
		params: &RecordFetcherMockSideEffectParams{ctx, reqID},
	}
	mmSideEffect.expectations = append(mmSideEffect.expectations, expectation)
	return expectation
}

// Then sets up RecordFetcher.SideEffect return parameters for the expectation previously defined by the When method
func (e *RecordFetcherMockSideEffectExpectation) Then(m1 record.Material, err error) *RecordFetcherMock {
	e.results = &RecordFetcherMockSideEffectResults{m1, err}
	return e.mock
}

// SideEffect implements RecordFetcher
func (mmSideEffect *RecordFetcherMock) SideEffect(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmSideEffect.beforeSideEffectCounter, 1)
	defer mm_atomic.AddUint64(&mmSideEffect.afterSideEffectCounter, 1)

	if mmSideEffect.inspectFuncSideEffect != nil {
		mmSideEffect.inspectFuncSideEffect(ctx, reqID)
	}

	params := &RecordFetcherMockSideEffectParams{ctx, reqID}

	// Record call args
	mmSideEffect.SideEffectMock.mutex.Lock()
	mmSideEffect.SideEffectMock.callArgs = append(mmSideEffect.SideEffectMock.callArgs, params)
	mmSideEffect.SideEffectMock.mutex.Unlock()

	for _, e := range mmSideEffect.SideEffectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmSideEffect.SideEffectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSideEffect.SideEffectMock.defaultExpectation.Counter, 1)
		want := mmSideEffect.SideEffectMock.defaultExpectation.params
		got := RecordFetcherMockSideEffectParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmSideEffect.t.Errorf("RecordFetcherMock.SideEffect got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSideEffect.SideEffectMock.defaultExpectation.results
		if results == nil {
			mmSideEffect.t.Fatal("No results are set for the RecordFetcherMock.SideEffect")
		}
		return (*results).m1, (*results).err
	}
	if mmSideEffect.funcSideEffect != nil {
		return mmSideEffect.funcSideEffect(ctx, reqID)
	}
	mmSideEffect.t.Fatalf("Unexpected call to RecordFetcherMock.SideEffect. %v %v", ctx, reqID)
	return
}

// SideEffectAfterCounter returns a count of finished RecordFetcherMock.SideEffect invocations
func (mmSideEffect *RecordFetcherMock) SideEffectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSideEffect.afterSideEffectCounter)
}

// SideEffectBeforeCounter returns a count of RecordFetcherMock.SideEffect invocations
func (mmSideEffect *RecordFetcherMock) SideEffectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSideEffect.beforeSideEffectCounter)
}

// Calls returns a list of arguments used in each call to RecordFetcherMock.SideEffect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSideEffect *mRecordFetcherMockSideEffect) Calls() []*RecordFetcherMockSideEffectParams {
	mmSideEffect.mutex.RLock()

	argCopy := make([]*RecordFetcherMockSideEffectParams, len(mmSideEffect.callArgs))
	copy(argCopy, mmSideEffect.callArgs)

	mmSideEffect.mutex.RUnlock()

	return argCopy
}

// MinimockSideEffectDone returns true if the count of the SideEffect invocations corresponds
// the number of defined expectations
func (m *RecordFetcherMock) MinimockSideEffectDone() bool {
	for _, e := range m.SideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSideEffect != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSideEffectInspect logs each unmet expectation
func (m *RecordFetcherMock) MinimockSideEffectInspect() {
	for _, e := range m.SideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordFetcherMock.SideEffect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		if m.SideEffectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordFetcherMock.SideEffect")
		} else {
			m.t.Errorf("Expected call to RecordFetcherMock.SideEffect with params: %#v", *m.SideEffectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSideEffect != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		m.t.Error("Expected call to RecordFetcherMock.SideEffect")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RecordFetcherMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCalledRequestsInspect()

		m.MinimockRequestInspect()

		m.MinimockResultInspect()

		m.MinimockSideEffectInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RecordFetcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RecordFetcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCalledRequestsDone() &&
		m.MinimockRequestDone() &&
		m.MinimockResultDone() &&
		m.MinimockSideEffectDone()
}
