package store

// Code generated by http://github.com/gojuno/minimock (2.1.9). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// RecordStoreMock implements RecordStore
type RecordStoreMock struct {
	t minimock.Tester

	funcCalledRequests          func(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error)
	inspectFuncCalledRequests   func(ctx context.Context, reqID insolar.ID)
	afterCalledRequestsCounter  uint64
	beforeCalledRequestsCounter uint64
	CalledRequestsMock          mRecordStoreMockCalledRequests

	funcFlush          func(ctx context.Context) (err error)
	inspectFuncFlush   func(ctx context.Context)
	afterFlushCounter  uint64
	beforeFlushCounter uint64
	FlushMock          mRecordStoreMockFlush

	funcRequest          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncRequest   func(ctx context.Context, reqID insolar.ID)
	afterRequestCounter  uint64
	beforeRequestCounter uint64
	RequestMock          mRecordStoreMockRequest

	funcResult          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncResult   func(ctx context.Context, reqID insolar.ID)
	afterResultCounter  uint64
	beforeResultCounter uint64
	ResultMock          mRecordStoreMockResult

	funcSetRequest          func(ctx context.Context, record record.Material) (err error)
	inspectFuncSetRequest   func(ctx context.Context, record record.Material)
	afterSetRequestCounter  uint64
	beforeSetRequestCounter uint64
	SetRequestMock          mRecordStoreMockSetRequest

	funcSetRequestBatch          func(ctx context.Context, requestRecords []record.Material) (err error)
	inspectFuncSetRequestBatch   func(ctx context.Context, requestRecords []record.Material)
	afterSetRequestBatchCounter  uint64
	beforeSetRequestBatchCounter uint64
	SetRequestBatchMock          mRecordStoreMockSetRequestBatch

	funcSetResult          func(ctx context.Context, record record.Material) (err error)
	inspectFuncSetResult   func(ctx context.Context, record record.Material)
	afterSetResultCounter  uint64
	beforeSetResultCounter uint64
	SetResultMock          mRecordStoreMockSetResult

	funcSetResultBatch          func(ctx context.Context, requestRecords []record.Material) (err error)
	inspectFuncSetResultBatch   func(ctx context.Context, requestRecords []record.Material)
	afterSetResultBatchCounter  uint64
	beforeSetResultBatchCounter uint64
	SetResultBatchMock          mRecordStoreMockSetResultBatch

	funcSetSideEffect          func(ctx context.Context, record record.Material) (err error)
	inspectFuncSetSideEffect   func(ctx context.Context, record record.Material)
	afterSetSideEffectCounter  uint64
	beforeSetSideEffectCounter uint64
	SetSideEffectMock          mRecordStoreMockSetSideEffect

	funcSetSideEffectBatch          func(ctx context.Context, requestRecords []record.Material) (err error)
	inspectFuncSetSideEffectBatch   func(ctx context.Context, requestRecords []record.Material)
	afterSetSideEffectBatchCounter  uint64
	beforeSetSideEffectBatchCounter uint64
	SetSideEffectBatchMock          mRecordStoreMockSetSideEffectBatch

	funcSideEffect          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncSideEffect   func(ctx context.Context, reqID insolar.ID)
	afterSideEffectCounter  uint64
	beforeSideEffectCounter uint64
	SideEffectMock          mRecordStoreMockSideEffect
}

// NewRecordStoreMock returns a mock for RecordStore
func NewRecordStoreMock(t minimock.Tester) *RecordStoreMock {
	m := &RecordStoreMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CalledRequestsMock = mRecordStoreMockCalledRequests{mock: m}
	m.CalledRequestsMock.callArgs = []*RecordStoreMockCalledRequestsParams{}

	m.FlushMock = mRecordStoreMockFlush{mock: m}
	m.FlushMock.callArgs = []*RecordStoreMockFlushParams{}

	m.RequestMock = mRecordStoreMockRequest{mock: m}
	m.RequestMock.callArgs = []*RecordStoreMockRequestParams{}

	m.ResultMock = mRecordStoreMockResult{mock: m}
	m.ResultMock.callArgs = []*RecordStoreMockResultParams{}

	m.SetRequestMock = mRecordStoreMockSetRequest{mock: m}
	m.SetRequestMock.callArgs = []*RecordStoreMockSetRequestParams{}

	m.SetRequestBatchMock = mRecordStoreMockSetRequestBatch{mock: m}
	m.SetRequestBatchMock.callArgs = []*RecordStoreMockSetRequestBatchParams{}

	m.SetResultMock = mRecordStoreMockSetResult{mock: m}
	m.SetResultMock.callArgs = []*RecordStoreMockSetResultParams{}

	m.SetResultBatchMock = mRecordStoreMockSetResultBatch{mock: m}
	m.SetResultBatchMock.callArgs = []*RecordStoreMockSetResultBatchParams{}

	m.SetSideEffectMock = mRecordStoreMockSetSideEffect{mock: m}
	m.SetSideEffectMock.callArgs = []*RecordStoreMockSetSideEffectParams{}

	m.SetSideEffectBatchMock = mRecordStoreMockSetSideEffectBatch{mock: m}
	m.SetSideEffectBatchMock.callArgs = []*RecordStoreMockSetSideEffectBatchParams{}

	m.SideEffectMock = mRecordStoreMockSideEffect{mock: m}
	m.SideEffectMock.callArgs = []*RecordStoreMockSideEffectParams{}

	return m
}

type mRecordStoreMockCalledRequests struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockCalledRequestsExpectation
	expectations       []*RecordStoreMockCalledRequestsExpectation

	callArgs []*RecordStoreMockCalledRequestsParams
	mutex    sync.RWMutex
}

// RecordStoreMockCalledRequestsExpectation specifies expectation struct of the RecordStore.CalledRequests
type RecordStoreMockCalledRequestsExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockCalledRequestsParams
	results *RecordStoreMockCalledRequestsResults
	Counter uint64
}

// RecordStoreMockCalledRequestsParams contains parameters of the RecordStore.CalledRequests
type RecordStoreMockCalledRequestsParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockCalledRequestsResults contains results of the RecordStore.CalledRequests
type RecordStoreMockCalledRequestsResults struct {
	ma1 []record.Material
	err error
}

// Expect sets up expected params for RecordStore.CalledRequests
func (mmCalledRequests *mRecordStoreMockCalledRequests) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockCalledRequests {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordStoreMock.CalledRequests mock is already set by Set")
	}

	if mmCalledRequests.defaultExpectation == nil {
		mmCalledRequests.defaultExpectation = &RecordStoreMockCalledRequestsExpectation{}
	}

	mmCalledRequests.defaultExpectation.params = &RecordStoreMockCalledRequestsParams{ctx, reqID}
	for _, e := range mmCalledRequests.expectations {
		if minimock.Equal(e.params, mmCalledRequests.defaultExpectation.params) {
			mmCalledRequests.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCalledRequests.defaultExpectation.params)
		}
	}

	return mmCalledRequests
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.CalledRequests
func (mmCalledRequests *mRecordStoreMockCalledRequests) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockCalledRequests {
	if mmCalledRequests.mock.inspectFuncCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.CalledRequests")
	}

	mmCalledRequests.mock.inspectFuncCalledRequests = f

	return mmCalledRequests
}

// Return sets up results that will be returned by RecordStore.CalledRequests
func (mmCalledRequests *mRecordStoreMockCalledRequests) Return(ma1 []record.Material, err error) *RecordStoreMock {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordStoreMock.CalledRequests mock is already set by Set")
	}

	if mmCalledRequests.defaultExpectation == nil {
		mmCalledRequests.defaultExpectation = &RecordStoreMockCalledRequestsExpectation{mock: mmCalledRequests.mock}
	}
	mmCalledRequests.defaultExpectation.results = &RecordStoreMockCalledRequestsResults{ma1, err}
	return mmCalledRequests.mock
}

//Set uses given function f to mock the RecordStore.CalledRequests method
func (mmCalledRequests *mRecordStoreMockCalledRequests) Set(f func(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error)) *RecordStoreMock {
	if mmCalledRequests.defaultExpectation != nil {
		mmCalledRequests.mock.t.Fatalf("Default expectation is already set for the RecordStore.CalledRequests method")
	}

	if len(mmCalledRequests.expectations) > 0 {
		mmCalledRequests.mock.t.Fatalf("Some expectations are already set for the RecordStore.CalledRequests method")
	}

	mmCalledRequests.mock.funcCalledRequests = f
	return mmCalledRequests.mock
}

// When sets expectation for the RecordStore.CalledRequests which will trigger the result defined by the following
// Then helper
func (mmCalledRequests *mRecordStoreMockCalledRequests) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockCalledRequestsExpectation {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordStoreMock.CalledRequests mock is already set by Set")
	}

	expectation := &RecordStoreMockCalledRequestsExpectation{
		mock:   mmCalledRequests.mock,
		params: &RecordStoreMockCalledRequestsParams{ctx, reqID},
	}
	mmCalledRequests.expectations = append(mmCalledRequests.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.CalledRequests return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockCalledRequestsExpectation) Then(ma1 []record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockCalledRequestsResults{ma1, err}
	return e.mock
}

// CalledRequests implements RecordStore
func (mmCalledRequests *RecordStoreMock) CalledRequests(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error) {
	mm_atomic.AddUint64(&mmCalledRequests.beforeCalledRequestsCounter, 1)
	defer mm_atomic.AddUint64(&mmCalledRequests.afterCalledRequestsCounter, 1)

	if mmCalledRequests.inspectFuncCalledRequests != nil {
		mmCalledRequests.inspectFuncCalledRequests(ctx, reqID)
	}

	mm_params := &RecordStoreMockCalledRequestsParams{ctx, reqID}

	// Record call args
	mmCalledRequests.CalledRequestsMock.mutex.Lock()
	mmCalledRequests.CalledRequestsMock.callArgs = append(mmCalledRequests.CalledRequestsMock.callArgs, mm_params)
	mmCalledRequests.CalledRequestsMock.mutex.Unlock()

	for _, e := range mmCalledRequests.CalledRequestsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmCalledRequests.CalledRequestsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCalledRequests.CalledRequestsMock.defaultExpectation.Counter, 1)
		mm_want := mmCalledRequests.CalledRequestsMock.defaultExpectation.params
		mm_got := RecordStoreMockCalledRequestsParams{ctx, reqID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCalledRequests.t.Errorf("RecordStoreMock.CalledRequests got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCalledRequests.CalledRequestsMock.defaultExpectation.results
		if mm_results == nil {
			mmCalledRequests.t.Fatal("No results are set for the RecordStoreMock.CalledRequests")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmCalledRequests.funcCalledRequests != nil {
		return mmCalledRequests.funcCalledRequests(ctx, reqID)
	}
	mmCalledRequests.t.Fatalf("Unexpected call to RecordStoreMock.CalledRequests. %v %v", ctx, reqID)
	return
}

// CalledRequestsAfterCounter returns a count of finished RecordStoreMock.CalledRequests invocations
func (mmCalledRequests *RecordStoreMock) CalledRequestsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalledRequests.afterCalledRequestsCounter)
}

// CalledRequestsBeforeCounter returns a count of RecordStoreMock.CalledRequests invocations
func (mmCalledRequests *RecordStoreMock) CalledRequestsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalledRequests.beforeCalledRequestsCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.CalledRequests.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCalledRequests *mRecordStoreMockCalledRequests) Calls() []*RecordStoreMockCalledRequestsParams {
	mmCalledRequests.mutex.RLock()

	argCopy := make([]*RecordStoreMockCalledRequestsParams, len(mmCalledRequests.callArgs))
	copy(argCopy, mmCalledRequests.callArgs)

	mmCalledRequests.mutex.RUnlock()

	return argCopy
}

// MinimockCalledRequestsDone returns true if the count of the CalledRequests invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockCalledRequestsDone() bool {
	for _, e := range m.CalledRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalledRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalledRequests != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCalledRequestsInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockCalledRequestsInspect() {
	for _, e := range m.CalledRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.CalledRequests with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalledRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		if m.CalledRequestsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.CalledRequests")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.CalledRequests with params: %#v", *m.CalledRequestsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalledRequests != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.CalledRequests")
	}
}

type mRecordStoreMockFlush struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockFlushExpectation
	expectations       []*RecordStoreMockFlushExpectation

	callArgs []*RecordStoreMockFlushParams
	mutex    sync.RWMutex
}

// RecordStoreMockFlushExpectation specifies expectation struct of the RecordStore.Flush
type RecordStoreMockFlushExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockFlushParams
	results *RecordStoreMockFlushResults
	Counter uint64
}

// RecordStoreMockFlushParams contains parameters of the RecordStore.Flush
type RecordStoreMockFlushParams struct {
	ctx context.Context
}

// RecordStoreMockFlushResults contains results of the RecordStore.Flush
type RecordStoreMockFlushResults struct {
	err error
}

// Expect sets up expected params for RecordStore.Flush
func (mmFlush *mRecordStoreMockFlush) Expect(ctx context.Context) *mRecordStoreMockFlush {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("RecordStoreMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &RecordStoreMockFlushExpectation{}
	}

	mmFlush.defaultExpectation.params = &RecordStoreMockFlushParams{ctx}
	for _, e := range mmFlush.expectations {
		if minimock.Equal(e.params, mmFlush.defaultExpectation.params) {
			mmFlush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFlush.defaultExpectation.params)
		}
	}

	return mmFlush
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.Flush
func (mmFlush *mRecordStoreMockFlush) Inspect(f func(ctx context.Context)) *mRecordStoreMockFlush {
	if mmFlush.mock.inspectFuncFlush != nil {
		mmFlush.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.Flush")
	}

	mmFlush.mock.inspectFuncFlush = f

	return mmFlush
}

// Return sets up results that will be returned by RecordStore.Flush
func (mmFlush *mRecordStoreMockFlush) Return(err error) *RecordStoreMock {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("RecordStoreMock.Flush mock is already set by Set")
	}

	if mmFlush.defaultExpectation == nil {
		mmFlush.defaultExpectation = &RecordStoreMockFlushExpectation{mock: mmFlush.mock}
	}
	mmFlush.defaultExpectation.results = &RecordStoreMockFlushResults{err}
	return mmFlush.mock
}

//Set uses given function f to mock the RecordStore.Flush method
func (mmFlush *mRecordStoreMockFlush) Set(f func(ctx context.Context) (err error)) *RecordStoreMock {
	if mmFlush.defaultExpectation != nil {
		mmFlush.mock.t.Fatalf("Default expectation is already set for the RecordStore.Flush method")
	}

	if len(mmFlush.expectations) > 0 {
		mmFlush.mock.t.Fatalf("Some expectations are already set for the RecordStore.Flush method")
	}

	mmFlush.mock.funcFlush = f
	return mmFlush.mock
}

// When sets expectation for the RecordStore.Flush which will trigger the result defined by the following
// Then helper
func (mmFlush *mRecordStoreMockFlush) When(ctx context.Context) *RecordStoreMockFlushExpectation {
	if mmFlush.mock.funcFlush != nil {
		mmFlush.mock.t.Fatalf("RecordStoreMock.Flush mock is already set by Set")
	}

	expectation := &RecordStoreMockFlushExpectation{
		mock:   mmFlush.mock,
		params: &RecordStoreMockFlushParams{ctx},
	}
	mmFlush.expectations = append(mmFlush.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.Flush return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockFlushExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockFlushResults{err}
	return e.mock
}

// Flush implements RecordStore
func (mmFlush *RecordStoreMock) Flush(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmFlush.beforeFlushCounter, 1)
	defer mm_atomic.AddUint64(&mmFlush.afterFlushCounter, 1)

	if mmFlush.inspectFuncFlush != nil {
		mmFlush.inspectFuncFlush(ctx)
	}

	mm_params := &RecordStoreMockFlushParams{ctx}

	// Record call args
	mmFlush.FlushMock.mutex.Lock()
	mmFlush.FlushMock.callArgs = append(mmFlush.FlushMock.callArgs, mm_params)
	mmFlush.FlushMock.mutex.Unlock()

	for _, e := range mmFlush.FlushMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFlush.FlushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFlush.FlushMock.defaultExpectation.Counter, 1)
		mm_want := mmFlush.FlushMock.defaultExpectation.params
		mm_got := RecordStoreMockFlushParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFlush.t.Errorf("RecordStoreMock.Flush got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFlush.FlushMock.defaultExpectation.results
		if mm_results == nil {
			mmFlush.t.Fatal("No results are set for the RecordStoreMock.Flush")
		}
		return (*mm_results).err
	}
	if mmFlush.funcFlush != nil {
		return mmFlush.funcFlush(ctx)
	}
	mmFlush.t.Fatalf("Unexpected call to RecordStoreMock.Flush. %v", ctx)
	return
}

// FlushAfterCounter returns a count of finished RecordStoreMock.Flush invocations
func (mmFlush *RecordStoreMock) FlushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.afterFlushCounter)
}

// FlushBeforeCounter returns a count of RecordStoreMock.Flush invocations
func (mmFlush *RecordStoreMock) FlushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFlush.beforeFlushCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.Flush.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFlush *mRecordStoreMockFlush) Calls() []*RecordStoreMockFlushParams {
	mmFlush.mutex.RLock()

	argCopy := make([]*RecordStoreMockFlushParams, len(mmFlush.callArgs))
	copy(argCopy, mmFlush.callArgs)

	mmFlush.mutex.RUnlock()

	return argCopy
}

// MinimockFlushDone returns true if the count of the Flush invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockFlushDone() bool {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		return false
	}
	return true
}

// MinimockFlushInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockFlushInspect() {
	for _, e := range m.FlushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.Flush with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FlushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		if m.FlushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.Flush")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.Flush with params: %#v", *m.FlushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFlush != nil && mm_atomic.LoadUint64(&m.afterFlushCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.Flush")
	}
}

type mRecordStoreMockRequest struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockRequestExpectation
	expectations       []*RecordStoreMockRequestExpectation

	callArgs []*RecordStoreMockRequestParams
	mutex    sync.RWMutex
}

// RecordStoreMockRequestExpectation specifies expectation struct of the RecordStore.Request
type RecordStoreMockRequestExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockRequestParams
	results *RecordStoreMockRequestResults
	Counter uint64
}

// RecordStoreMockRequestParams contains parameters of the RecordStore.Request
type RecordStoreMockRequestParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockRequestResults contains results of the RecordStore.Request
type RecordStoreMockRequestResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordStore.Request
func (mmRequest *mRecordStoreMockRequest) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockRequest {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordStoreMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &RecordStoreMockRequestExpectation{}
	}

	mmRequest.defaultExpectation.params = &RecordStoreMockRequestParams{ctx, reqID}
	for _, e := range mmRequest.expectations {
		if minimock.Equal(e.params, mmRequest.defaultExpectation.params) {
			mmRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequest.defaultExpectation.params)
		}
	}

	return mmRequest
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.Request
func (mmRequest *mRecordStoreMockRequest) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockRequest {
	if mmRequest.mock.inspectFuncRequest != nil {
		mmRequest.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.Request")
	}

	mmRequest.mock.inspectFuncRequest = f

	return mmRequest
}

// Return sets up results that will be returned by RecordStore.Request
func (mmRequest *mRecordStoreMockRequest) Return(m1 record.Material, err error) *RecordStoreMock {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordStoreMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &RecordStoreMockRequestExpectation{mock: mmRequest.mock}
	}
	mmRequest.defaultExpectation.results = &RecordStoreMockRequestResults{m1, err}
	return mmRequest.mock
}

//Set uses given function f to mock the RecordStore.Request method
func (mmRequest *mRecordStoreMockRequest) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordStoreMock {
	if mmRequest.defaultExpectation != nil {
		mmRequest.mock.t.Fatalf("Default expectation is already set for the RecordStore.Request method")
	}

	if len(mmRequest.expectations) > 0 {
		mmRequest.mock.t.Fatalf("Some expectations are already set for the RecordStore.Request method")
	}

	mmRequest.mock.funcRequest = f
	return mmRequest.mock
}

// When sets expectation for the RecordStore.Request which will trigger the result defined by the following
// Then helper
func (mmRequest *mRecordStoreMockRequest) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockRequestExpectation {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordStoreMock.Request mock is already set by Set")
	}

	expectation := &RecordStoreMockRequestExpectation{
		mock:   mmRequest.mock,
		params: &RecordStoreMockRequestParams{ctx, reqID},
	}
	mmRequest.expectations = append(mmRequest.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.Request return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockRequestExpectation) Then(m1 record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockRequestResults{m1, err}
	return e.mock
}

// Request implements RecordStore
func (mmRequest *RecordStoreMock) Request(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmRequest.beforeRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRequest.afterRequestCounter, 1)

	if mmRequest.inspectFuncRequest != nil {
		mmRequest.inspectFuncRequest(ctx, reqID)
	}

	mm_params := &RecordStoreMockRequestParams{ctx, reqID}

	// Record call args
	mmRequest.RequestMock.mutex.Lock()
	mmRequest.RequestMock.callArgs = append(mmRequest.RequestMock.callArgs, mm_params)
	mmRequest.RequestMock.mutex.Unlock()

	for _, e := range mmRequest.RequestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmRequest.RequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequest.RequestMock.defaultExpectation.Counter, 1)
		mm_want := mmRequest.RequestMock.defaultExpectation.params
		mm_got := RecordStoreMockRequestParams{ctx, reqID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequest.t.Errorf("RecordStoreMock.Request got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRequest.RequestMock.defaultExpectation.results
		if mm_results == nil {
			mmRequest.t.Fatal("No results are set for the RecordStoreMock.Request")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmRequest.funcRequest != nil {
		return mmRequest.funcRequest(ctx, reqID)
	}
	mmRequest.t.Fatalf("Unexpected call to RecordStoreMock.Request. %v %v", ctx, reqID)
	return
}

// RequestAfterCounter returns a count of finished RecordStoreMock.Request invocations
func (mmRequest *RecordStoreMock) RequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.afterRequestCounter)
}

// RequestBeforeCounter returns a count of RecordStoreMock.Request invocations
func (mmRequest *RecordStoreMock) RequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.beforeRequestCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.Request.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequest *mRecordStoreMockRequest) Calls() []*RecordStoreMockRequestParams {
	mmRequest.mutex.RLock()

	argCopy := make([]*RecordStoreMockRequestParams, len(mmRequest.callArgs))
	copy(argCopy, mmRequest.callArgs)

	mmRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRequestDone returns true if the count of the Request invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockRequestDone() bool {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockRequestInspect() {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.Request with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		if m.RequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.Request")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.Request with params: %#v", *m.RequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.Request")
	}
}

type mRecordStoreMockResult struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockResultExpectation
	expectations       []*RecordStoreMockResultExpectation

	callArgs []*RecordStoreMockResultParams
	mutex    sync.RWMutex
}

// RecordStoreMockResultExpectation specifies expectation struct of the RecordStore.Result
type RecordStoreMockResultExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockResultParams
	results *RecordStoreMockResultResults
	Counter uint64
}

// RecordStoreMockResultParams contains parameters of the RecordStore.Result
type RecordStoreMockResultParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockResultResults contains results of the RecordStore.Result
type RecordStoreMockResultResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordStore.Result
func (mmResult *mRecordStoreMockResult) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockResult {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordStoreMock.Result mock is already set by Set")
	}

	if mmResult.defaultExpectation == nil {
		mmResult.defaultExpectation = &RecordStoreMockResultExpectation{}
	}

	mmResult.defaultExpectation.params = &RecordStoreMockResultParams{ctx, reqID}
	for _, e := range mmResult.expectations {
		if minimock.Equal(e.params, mmResult.defaultExpectation.params) {
			mmResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResult.defaultExpectation.params)
		}
	}

	return mmResult
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.Result
func (mmResult *mRecordStoreMockResult) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockResult {
	if mmResult.mock.inspectFuncResult != nil {
		mmResult.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.Result")
	}

	mmResult.mock.inspectFuncResult = f

	return mmResult
}

// Return sets up results that will be returned by RecordStore.Result
func (mmResult *mRecordStoreMockResult) Return(m1 record.Material, err error) *RecordStoreMock {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordStoreMock.Result mock is already set by Set")
	}

	if mmResult.defaultExpectation == nil {
		mmResult.defaultExpectation = &RecordStoreMockResultExpectation{mock: mmResult.mock}
	}
	mmResult.defaultExpectation.results = &RecordStoreMockResultResults{m1, err}
	return mmResult.mock
}

//Set uses given function f to mock the RecordStore.Result method
func (mmResult *mRecordStoreMockResult) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordStoreMock {
	if mmResult.defaultExpectation != nil {
		mmResult.mock.t.Fatalf("Default expectation is already set for the RecordStore.Result method")
	}

	if len(mmResult.expectations) > 0 {
		mmResult.mock.t.Fatalf("Some expectations are already set for the RecordStore.Result method")
	}

	mmResult.mock.funcResult = f
	return mmResult.mock
}

// When sets expectation for the RecordStore.Result which will trigger the result defined by the following
// Then helper
func (mmResult *mRecordStoreMockResult) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockResultExpectation {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordStoreMock.Result mock is already set by Set")
	}

	expectation := &RecordStoreMockResultExpectation{
		mock:   mmResult.mock,
		params: &RecordStoreMockResultParams{ctx, reqID},
	}
	mmResult.expectations = append(mmResult.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.Result return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockResultExpectation) Then(m1 record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockResultResults{m1, err}
	return e.mock
}

// Result implements RecordStore
func (mmResult *RecordStoreMock) Result(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmResult.beforeResultCounter, 1)
	defer mm_atomic.AddUint64(&mmResult.afterResultCounter, 1)

	if mmResult.inspectFuncResult != nil {
		mmResult.inspectFuncResult(ctx, reqID)
	}

	mm_params := &RecordStoreMockResultParams{ctx, reqID}

	// Record call args
	mmResult.ResultMock.mutex.Lock()
	mmResult.ResultMock.callArgs = append(mmResult.ResultMock.callArgs, mm_params)
	mmResult.ResultMock.mutex.Unlock()

	for _, e := range mmResult.ResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmResult.ResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResult.ResultMock.defaultExpectation.Counter, 1)
		mm_want := mmResult.ResultMock.defaultExpectation.params
		mm_got := RecordStoreMockResultParams{ctx, reqID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResult.t.Errorf("RecordStoreMock.Result got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmResult.ResultMock.defaultExpectation.results
		if mm_results == nil {
			mmResult.t.Fatal("No results are set for the RecordStoreMock.Result")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmResult.funcResult != nil {
		return mmResult.funcResult(ctx, reqID)
	}
	mmResult.t.Fatalf("Unexpected call to RecordStoreMock.Result. %v %v", ctx, reqID)
	return
}

// ResultAfterCounter returns a count of finished RecordStoreMock.Result invocations
func (mmResult *RecordStoreMock) ResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResult.afterResultCounter)
}

// ResultBeforeCounter returns a count of RecordStoreMock.Result invocations
func (mmResult *RecordStoreMock) ResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResult.beforeResultCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.Result.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResult *mRecordStoreMockResult) Calls() []*RecordStoreMockResultParams {
	mmResult.mutex.RLock()

	argCopy := make([]*RecordStoreMockResultParams, len(mmResult.callArgs))
	copy(argCopy, mmResult.callArgs)

	mmResult.mutex.RUnlock()

	return argCopy
}

// MinimockResultDone returns true if the count of the Result invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockResultDone() bool {
	for _, e := range m.ResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResult != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockResultInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockResultInspect() {
	for _, e := range m.ResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.Result with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		if m.ResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.Result")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.Result with params: %#v", *m.ResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResult != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.Result")
	}
}

type mRecordStoreMockSetRequest struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetRequestExpectation
	expectations       []*RecordStoreMockSetRequestExpectation

	callArgs []*RecordStoreMockSetRequestParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetRequestExpectation specifies expectation struct of the RecordStore.SetRequest
type RecordStoreMockSetRequestExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetRequestParams
	results *RecordStoreMockSetRequestResults
	Counter uint64
}

// RecordStoreMockSetRequestParams contains parameters of the RecordStore.SetRequest
type RecordStoreMockSetRequestParams struct {
	ctx    context.Context
	record record.Material
}

// RecordStoreMockSetRequestResults contains results of the RecordStore.SetRequest
type RecordStoreMockSetRequestResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetRequest
func (mmSetRequest *mRecordStoreMockSetRequest) Expect(ctx context.Context, record record.Material) *mRecordStoreMockSetRequest {
	if mmSetRequest.mock.funcSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("RecordStoreMock.SetRequest mock is already set by Set")
	}

	if mmSetRequest.defaultExpectation == nil {
		mmSetRequest.defaultExpectation = &RecordStoreMockSetRequestExpectation{}
	}

	mmSetRequest.defaultExpectation.params = &RecordStoreMockSetRequestParams{ctx, record}
	for _, e := range mmSetRequest.expectations {
		if minimock.Equal(e.params, mmSetRequest.defaultExpectation.params) {
			mmSetRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRequest.defaultExpectation.params)
		}
	}

	return mmSetRequest
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetRequest
func (mmSetRequest *mRecordStoreMockSetRequest) Inspect(f func(ctx context.Context, record record.Material)) *mRecordStoreMockSetRequest {
	if mmSetRequest.mock.inspectFuncSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetRequest")
	}

	mmSetRequest.mock.inspectFuncSetRequest = f

	return mmSetRequest
}

// Return sets up results that will be returned by RecordStore.SetRequest
func (mmSetRequest *mRecordStoreMockSetRequest) Return(err error) *RecordStoreMock {
	if mmSetRequest.mock.funcSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("RecordStoreMock.SetRequest mock is already set by Set")
	}

	if mmSetRequest.defaultExpectation == nil {
		mmSetRequest.defaultExpectation = &RecordStoreMockSetRequestExpectation{mock: mmSetRequest.mock}
	}
	mmSetRequest.defaultExpectation.results = &RecordStoreMockSetRequestResults{err}
	return mmSetRequest.mock
}

//Set uses given function f to mock the RecordStore.SetRequest method
func (mmSetRequest *mRecordStoreMockSetRequest) Set(f func(ctx context.Context, record record.Material) (err error)) *RecordStoreMock {
	if mmSetRequest.defaultExpectation != nil {
		mmSetRequest.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetRequest method")
	}

	if len(mmSetRequest.expectations) > 0 {
		mmSetRequest.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetRequest method")
	}

	mmSetRequest.mock.funcSetRequest = f
	return mmSetRequest.mock
}

// When sets expectation for the RecordStore.SetRequest which will trigger the result defined by the following
// Then helper
func (mmSetRequest *mRecordStoreMockSetRequest) When(ctx context.Context, record record.Material) *RecordStoreMockSetRequestExpectation {
	if mmSetRequest.mock.funcSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("RecordStoreMock.SetRequest mock is already set by Set")
	}

	expectation := &RecordStoreMockSetRequestExpectation{
		mock:   mmSetRequest.mock,
		params: &RecordStoreMockSetRequestParams{ctx, record},
	}
	mmSetRequest.expectations = append(mmSetRequest.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetRequest return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetRequestExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetRequestResults{err}
	return e.mock
}

// SetRequest implements RecordStore
func (mmSetRequest *RecordStoreMock) SetRequest(ctx context.Context, record record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetRequest.beforeSetRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRequest.afterSetRequestCounter, 1)

	if mmSetRequest.inspectFuncSetRequest != nil {
		mmSetRequest.inspectFuncSetRequest(ctx, record)
	}

	mm_params := &RecordStoreMockSetRequestParams{ctx, record}

	// Record call args
	mmSetRequest.SetRequestMock.mutex.Lock()
	mmSetRequest.SetRequestMock.callArgs = append(mmSetRequest.SetRequestMock.callArgs, mm_params)
	mmSetRequest.SetRequestMock.mutex.Unlock()

	for _, e := range mmSetRequest.SetRequestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetRequest.SetRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRequest.SetRequestMock.defaultExpectation.Counter, 1)
		mm_want := mmSetRequest.SetRequestMock.defaultExpectation.params
		mm_got := RecordStoreMockSetRequestParams{ctx, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetRequest.t.Errorf("RecordStoreMock.SetRequest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetRequest.SetRequestMock.defaultExpectation.results
		if mm_results == nil {
			mmSetRequest.t.Fatal("No results are set for the RecordStoreMock.SetRequest")
		}
		return (*mm_results).err
	}
	if mmSetRequest.funcSetRequest != nil {
		return mmSetRequest.funcSetRequest(ctx, record)
	}
	mmSetRequest.t.Fatalf("Unexpected call to RecordStoreMock.SetRequest. %v %v", ctx, record)
	return
}

// SetRequestAfterCounter returns a count of finished RecordStoreMock.SetRequest invocations
func (mmSetRequest *RecordStoreMock) SetRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRequest.afterSetRequestCounter)
}

// SetRequestBeforeCounter returns a count of RecordStoreMock.SetRequest invocations
func (mmSetRequest *RecordStoreMock) SetRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRequest.beforeSetRequestCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRequest *mRecordStoreMockSetRequest) Calls() []*RecordStoreMockSetRequestParams {
	mmSetRequest.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetRequestParams, len(mmSetRequest.callArgs))
	copy(argCopy, mmSetRequest.callArgs)

	mmSetRequest.mutex.RUnlock()

	return argCopy
}

// MinimockSetRequestDone returns true if the count of the SetRequest invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetRequestDone() bool {
	for _, e := range m.SetRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRequest != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetRequestInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetRequestInspect() {
	for _, e := range m.SetRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		if m.SetRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetRequest")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetRequest with params: %#v", *m.SetRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRequest != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetRequest")
	}
}

type mRecordStoreMockSetRequestBatch struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetRequestBatchExpectation
	expectations       []*RecordStoreMockSetRequestBatchExpectation

	callArgs []*RecordStoreMockSetRequestBatchParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetRequestBatchExpectation specifies expectation struct of the RecordStore.SetRequestBatch
type RecordStoreMockSetRequestBatchExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetRequestBatchParams
	results *RecordStoreMockSetRequestBatchResults
	Counter uint64
}

// RecordStoreMockSetRequestBatchParams contains parameters of the RecordStore.SetRequestBatch
type RecordStoreMockSetRequestBatchParams struct {
	ctx            context.Context
	requestRecords []record.Material
}

// RecordStoreMockSetRequestBatchResults contains results of the RecordStore.SetRequestBatch
type RecordStoreMockSetRequestBatchResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetRequestBatch
func (mmSetRequestBatch *mRecordStoreMockSetRequestBatch) Expect(ctx context.Context, requestRecords []record.Material) *mRecordStoreMockSetRequestBatch {
	if mmSetRequestBatch.mock.funcSetRequestBatch != nil {
		mmSetRequestBatch.mock.t.Fatalf("RecordStoreMock.SetRequestBatch mock is already set by Set")
	}

	if mmSetRequestBatch.defaultExpectation == nil {
		mmSetRequestBatch.defaultExpectation = &RecordStoreMockSetRequestBatchExpectation{}
	}

	mmSetRequestBatch.defaultExpectation.params = &RecordStoreMockSetRequestBatchParams{ctx, requestRecords}
	for _, e := range mmSetRequestBatch.expectations {
		if minimock.Equal(e.params, mmSetRequestBatch.defaultExpectation.params) {
			mmSetRequestBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRequestBatch.defaultExpectation.params)
		}
	}

	return mmSetRequestBatch
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetRequestBatch
func (mmSetRequestBatch *mRecordStoreMockSetRequestBatch) Inspect(f func(ctx context.Context, requestRecords []record.Material)) *mRecordStoreMockSetRequestBatch {
	if mmSetRequestBatch.mock.inspectFuncSetRequestBatch != nil {
		mmSetRequestBatch.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetRequestBatch")
	}

	mmSetRequestBatch.mock.inspectFuncSetRequestBatch = f

	return mmSetRequestBatch
}

// Return sets up results that will be returned by RecordStore.SetRequestBatch
func (mmSetRequestBatch *mRecordStoreMockSetRequestBatch) Return(err error) *RecordStoreMock {
	if mmSetRequestBatch.mock.funcSetRequestBatch != nil {
		mmSetRequestBatch.mock.t.Fatalf("RecordStoreMock.SetRequestBatch mock is already set by Set")
	}

	if mmSetRequestBatch.defaultExpectation == nil {
		mmSetRequestBatch.defaultExpectation = &RecordStoreMockSetRequestBatchExpectation{mock: mmSetRequestBatch.mock}
	}
	mmSetRequestBatch.defaultExpectation.results = &RecordStoreMockSetRequestBatchResults{err}
	return mmSetRequestBatch.mock
}

//Set uses given function f to mock the RecordStore.SetRequestBatch method
func (mmSetRequestBatch *mRecordStoreMockSetRequestBatch) Set(f func(ctx context.Context, requestRecords []record.Material) (err error)) *RecordStoreMock {
	if mmSetRequestBatch.defaultExpectation != nil {
		mmSetRequestBatch.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetRequestBatch method")
	}

	if len(mmSetRequestBatch.expectations) > 0 {
		mmSetRequestBatch.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetRequestBatch method")
	}

	mmSetRequestBatch.mock.funcSetRequestBatch = f
	return mmSetRequestBatch.mock
}

// When sets expectation for the RecordStore.SetRequestBatch which will trigger the result defined by the following
// Then helper
func (mmSetRequestBatch *mRecordStoreMockSetRequestBatch) When(ctx context.Context, requestRecords []record.Material) *RecordStoreMockSetRequestBatchExpectation {
	if mmSetRequestBatch.mock.funcSetRequestBatch != nil {
		mmSetRequestBatch.mock.t.Fatalf("RecordStoreMock.SetRequestBatch mock is already set by Set")
	}

	expectation := &RecordStoreMockSetRequestBatchExpectation{
		mock:   mmSetRequestBatch.mock,
		params: &RecordStoreMockSetRequestBatchParams{ctx, requestRecords},
	}
	mmSetRequestBatch.expectations = append(mmSetRequestBatch.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetRequestBatch return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetRequestBatchExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetRequestBatchResults{err}
	return e.mock
}

// SetRequestBatch implements RecordStore
func (mmSetRequestBatch *RecordStoreMock) SetRequestBatch(ctx context.Context, requestRecords []record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetRequestBatch.beforeSetRequestBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRequestBatch.afterSetRequestBatchCounter, 1)

	if mmSetRequestBatch.inspectFuncSetRequestBatch != nil {
		mmSetRequestBatch.inspectFuncSetRequestBatch(ctx, requestRecords)
	}

	mm_params := &RecordStoreMockSetRequestBatchParams{ctx, requestRecords}

	// Record call args
	mmSetRequestBatch.SetRequestBatchMock.mutex.Lock()
	mmSetRequestBatch.SetRequestBatchMock.callArgs = append(mmSetRequestBatch.SetRequestBatchMock.callArgs, mm_params)
	mmSetRequestBatch.SetRequestBatchMock.mutex.Unlock()

	for _, e := range mmSetRequestBatch.SetRequestBatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetRequestBatch.SetRequestBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRequestBatch.SetRequestBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSetRequestBatch.SetRequestBatchMock.defaultExpectation.params
		mm_got := RecordStoreMockSetRequestBatchParams{ctx, requestRecords}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetRequestBatch.t.Errorf("RecordStoreMock.SetRequestBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetRequestBatch.SetRequestBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSetRequestBatch.t.Fatal("No results are set for the RecordStoreMock.SetRequestBatch")
		}
		return (*mm_results).err
	}
	if mmSetRequestBatch.funcSetRequestBatch != nil {
		return mmSetRequestBatch.funcSetRequestBatch(ctx, requestRecords)
	}
	mmSetRequestBatch.t.Fatalf("Unexpected call to RecordStoreMock.SetRequestBatch. %v %v", ctx, requestRecords)
	return
}

// SetRequestBatchAfterCounter returns a count of finished RecordStoreMock.SetRequestBatch invocations
func (mmSetRequestBatch *RecordStoreMock) SetRequestBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRequestBatch.afterSetRequestBatchCounter)
}

// SetRequestBatchBeforeCounter returns a count of RecordStoreMock.SetRequestBatch invocations
func (mmSetRequestBatch *RecordStoreMock) SetRequestBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRequestBatch.beforeSetRequestBatchCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetRequestBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRequestBatch *mRecordStoreMockSetRequestBatch) Calls() []*RecordStoreMockSetRequestBatchParams {
	mmSetRequestBatch.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetRequestBatchParams, len(mmSetRequestBatch.callArgs))
	copy(argCopy, mmSetRequestBatch.callArgs)

	mmSetRequestBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSetRequestBatchDone returns true if the count of the SetRequestBatch invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetRequestBatchDone() bool {
	for _, e := range m.SetRequestBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRequestBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRequestBatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRequestBatch != nil && mm_atomic.LoadUint64(&m.afterSetRequestBatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetRequestBatchInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetRequestBatchInspect() {
	for _, e := range m.SetRequestBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetRequestBatch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRequestBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRequestBatchCounter) < 1 {
		if m.SetRequestBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetRequestBatch")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetRequestBatch with params: %#v", *m.SetRequestBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRequestBatch != nil && mm_atomic.LoadUint64(&m.afterSetRequestBatchCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetRequestBatch")
	}
}

type mRecordStoreMockSetResult struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetResultExpectation
	expectations       []*RecordStoreMockSetResultExpectation

	callArgs []*RecordStoreMockSetResultParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetResultExpectation specifies expectation struct of the RecordStore.SetResult
type RecordStoreMockSetResultExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetResultParams
	results *RecordStoreMockSetResultResults
	Counter uint64
}

// RecordStoreMockSetResultParams contains parameters of the RecordStore.SetResult
type RecordStoreMockSetResultParams struct {
	ctx    context.Context
	record record.Material
}

// RecordStoreMockSetResultResults contains results of the RecordStore.SetResult
type RecordStoreMockSetResultResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetResult
func (mmSetResult *mRecordStoreMockSetResult) Expect(ctx context.Context, record record.Material) *mRecordStoreMockSetResult {
	if mmSetResult.mock.funcSetResult != nil {
		mmSetResult.mock.t.Fatalf("RecordStoreMock.SetResult mock is already set by Set")
	}

	if mmSetResult.defaultExpectation == nil {
		mmSetResult.defaultExpectation = &RecordStoreMockSetResultExpectation{}
	}

	mmSetResult.defaultExpectation.params = &RecordStoreMockSetResultParams{ctx, record}
	for _, e := range mmSetResult.expectations {
		if minimock.Equal(e.params, mmSetResult.defaultExpectation.params) {
			mmSetResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetResult.defaultExpectation.params)
		}
	}

	return mmSetResult
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetResult
func (mmSetResult *mRecordStoreMockSetResult) Inspect(f func(ctx context.Context, record record.Material)) *mRecordStoreMockSetResult {
	if mmSetResult.mock.inspectFuncSetResult != nil {
		mmSetResult.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetResult")
	}

	mmSetResult.mock.inspectFuncSetResult = f

	return mmSetResult
}

// Return sets up results that will be returned by RecordStore.SetResult
func (mmSetResult *mRecordStoreMockSetResult) Return(err error) *RecordStoreMock {
	if mmSetResult.mock.funcSetResult != nil {
		mmSetResult.mock.t.Fatalf("RecordStoreMock.SetResult mock is already set by Set")
	}

	if mmSetResult.defaultExpectation == nil {
		mmSetResult.defaultExpectation = &RecordStoreMockSetResultExpectation{mock: mmSetResult.mock}
	}
	mmSetResult.defaultExpectation.results = &RecordStoreMockSetResultResults{err}
	return mmSetResult.mock
}

//Set uses given function f to mock the RecordStore.SetResult method
func (mmSetResult *mRecordStoreMockSetResult) Set(f func(ctx context.Context, record record.Material) (err error)) *RecordStoreMock {
	if mmSetResult.defaultExpectation != nil {
		mmSetResult.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetResult method")
	}

	if len(mmSetResult.expectations) > 0 {
		mmSetResult.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetResult method")
	}

	mmSetResult.mock.funcSetResult = f
	return mmSetResult.mock
}

// When sets expectation for the RecordStore.SetResult which will trigger the result defined by the following
// Then helper
func (mmSetResult *mRecordStoreMockSetResult) When(ctx context.Context, record record.Material) *RecordStoreMockSetResultExpectation {
	if mmSetResult.mock.funcSetResult != nil {
		mmSetResult.mock.t.Fatalf("RecordStoreMock.SetResult mock is already set by Set")
	}

	expectation := &RecordStoreMockSetResultExpectation{
		mock:   mmSetResult.mock,
		params: &RecordStoreMockSetResultParams{ctx, record},
	}
	mmSetResult.expectations = append(mmSetResult.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetResult return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetResultExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetResultResults{err}
	return e.mock
}

// SetResult implements RecordStore
func (mmSetResult *RecordStoreMock) SetResult(ctx context.Context, record record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetResult.beforeSetResultCounter, 1)
	defer mm_atomic.AddUint64(&mmSetResult.afterSetResultCounter, 1)

	if mmSetResult.inspectFuncSetResult != nil {
		mmSetResult.inspectFuncSetResult(ctx, record)
	}

	mm_params := &RecordStoreMockSetResultParams{ctx, record}

	// Record call args
	mmSetResult.SetResultMock.mutex.Lock()
	mmSetResult.SetResultMock.callArgs = append(mmSetResult.SetResultMock.callArgs, mm_params)
	mmSetResult.SetResultMock.mutex.Unlock()

	for _, e := range mmSetResult.SetResultMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetResult.SetResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetResult.SetResultMock.defaultExpectation.Counter, 1)
		mm_want := mmSetResult.SetResultMock.defaultExpectation.params
		mm_got := RecordStoreMockSetResultParams{ctx, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetResult.t.Errorf("RecordStoreMock.SetResult got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetResult.SetResultMock.defaultExpectation.results
		if mm_results == nil {
			mmSetResult.t.Fatal("No results are set for the RecordStoreMock.SetResult")
		}
		return (*mm_results).err
	}
	if mmSetResult.funcSetResult != nil {
		return mmSetResult.funcSetResult(ctx, record)
	}
	mmSetResult.t.Fatalf("Unexpected call to RecordStoreMock.SetResult. %v %v", ctx, record)
	return
}

// SetResultAfterCounter returns a count of finished RecordStoreMock.SetResult invocations
func (mmSetResult *RecordStoreMock) SetResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetResult.afterSetResultCounter)
}

// SetResultBeforeCounter returns a count of RecordStoreMock.SetResult invocations
func (mmSetResult *RecordStoreMock) SetResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetResult.beforeSetResultCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetResult *mRecordStoreMockSetResult) Calls() []*RecordStoreMockSetResultParams {
	mmSetResult.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetResultParams, len(mmSetResult.callArgs))
	copy(argCopy, mmSetResult.callArgs)

	mmSetResult.mutex.RUnlock()

	return argCopy
}

// MinimockSetResultDone returns true if the count of the SetResult invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetResultDone() bool {
	for _, e := range m.SetResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetResult != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetResultInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetResultInspect() {
	for _, e := range m.SetResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		if m.SetResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetResult")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetResult with params: %#v", *m.SetResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetResult != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetResult")
	}
}

type mRecordStoreMockSetResultBatch struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetResultBatchExpectation
	expectations       []*RecordStoreMockSetResultBatchExpectation

	callArgs []*RecordStoreMockSetResultBatchParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetResultBatchExpectation specifies expectation struct of the RecordStore.SetResultBatch
type RecordStoreMockSetResultBatchExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetResultBatchParams
	results *RecordStoreMockSetResultBatchResults
	Counter uint64
}

// RecordStoreMockSetResultBatchParams contains parameters of the RecordStore.SetResultBatch
type RecordStoreMockSetResultBatchParams struct {
	ctx            context.Context
	requestRecords []record.Material
}

// RecordStoreMockSetResultBatchResults contains results of the RecordStore.SetResultBatch
type RecordStoreMockSetResultBatchResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetResultBatch
func (mmSetResultBatch *mRecordStoreMockSetResultBatch) Expect(ctx context.Context, requestRecords []record.Material) *mRecordStoreMockSetResultBatch {
	if mmSetResultBatch.mock.funcSetResultBatch != nil {
		mmSetResultBatch.mock.t.Fatalf("RecordStoreMock.SetResultBatch mock is already set by Set")
	}

	if mmSetResultBatch.defaultExpectation == nil {
		mmSetResultBatch.defaultExpectation = &RecordStoreMockSetResultBatchExpectation{}
	}

	mmSetResultBatch.defaultExpectation.params = &RecordStoreMockSetResultBatchParams{ctx, requestRecords}
	for _, e := range mmSetResultBatch.expectations {
		if minimock.Equal(e.params, mmSetResultBatch.defaultExpectation.params) {
			mmSetResultBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetResultBatch.defaultExpectation.params)
		}
	}

	return mmSetResultBatch
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetResultBatch
func (mmSetResultBatch *mRecordStoreMockSetResultBatch) Inspect(f func(ctx context.Context, requestRecords []record.Material)) *mRecordStoreMockSetResultBatch {
	if mmSetResultBatch.mock.inspectFuncSetResultBatch != nil {
		mmSetResultBatch.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetResultBatch")
	}

	mmSetResultBatch.mock.inspectFuncSetResultBatch = f

	return mmSetResultBatch
}

// Return sets up results that will be returned by RecordStore.SetResultBatch
func (mmSetResultBatch *mRecordStoreMockSetResultBatch) Return(err error) *RecordStoreMock {
	if mmSetResultBatch.mock.funcSetResultBatch != nil {
		mmSetResultBatch.mock.t.Fatalf("RecordStoreMock.SetResultBatch mock is already set by Set")
	}

	if mmSetResultBatch.defaultExpectation == nil {
		mmSetResultBatch.defaultExpectation = &RecordStoreMockSetResultBatchExpectation{mock: mmSetResultBatch.mock}
	}
	mmSetResultBatch.defaultExpectation.results = &RecordStoreMockSetResultBatchResults{err}
	return mmSetResultBatch.mock
}

//Set uses given function f to mock the RecordStore.SetResultBatch method
func (mmSetResultBatch *mRecordStoreMockSetResultBatch) Set(f func(ctx context.Context, requestRecords []record.Material) (err error)) *RecordStoreMock {
	if mmSetResultBatch.defaultExpectation != nil {
		mmSetResultBatch.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetResultBatch method")
	}

	if len(mmSetResultBatch.expectations) > 0 {
		mmSetResultBatch.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetResultBatch method")
	}

	mmSetResultBatch.mock.funcSetResultBatch = f
	return mmSetResultBatch.mock
}

// When sets expectation for the RecordStore.SetResultBatch which will trigger the result defined by the following
// Then helper
func (mmSetResultBatch *mRecordStoreMockSetResultBatch) When(ctx context.Context, requestRecords []record.Material) *RecordStoreMockSetResultBatchExpectation {
	if mmSetResultBatch.mock.funcSetResultBatch != nil {
		mmSetResultBatch.mock.t.Fatalf("RecordStoreMock.SetResultBatch mock is already set by Set")
	}

	expectation := &RecordStoreMockSetResultBatchExpectation{
		mock:   mmSetResultBatch.mock,
		params: &RecordStoreMockSetResultBatchParams{ctx, requestRecords},
	}
	mmSetResultBatch.expectations = append(mmSetResultBatch.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetResultBatch return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetResultBatchExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetResultBatchResults{err}
	return e.mock
}

// SetResultBatch implements RecordStore
func (mmSetResultBatch *RecordStoreMock) SetResultBatch(ctx context.Context, requestRecords []record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetResultBatch.beforeSetResultBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSetResultBatch.afterSetResultBatchCounter, 1)

	if mmSetResultBatch.inspectFuncSetResultBatch != nil {
		mmSetResultBatch.inspectFuncSetResultBatch(ctx, requestRecords)
	}

	mm_params := &RecordStoreMockSetResultBatchParams{ctx, requestRecords}

	// Record call args
	mmSetResultBatch.SetResultBatchMock.mutex.Lock()
	mmSetResultBatch.SetResultBatchMock.callArgs = append(mmSetResultBatch.SetResultBatchMock.callArgs, mm_params)
	mmSetResultBatch.SetResultBatchMock.mutex.Unlock()

	for _, e := range mmSetResultBatch.SetResultBatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetResultBatch.SetResultBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetResultBatch.SetResultBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSetResultBatch.SetResultBatchMock.defaultExpectation.params
		mm_got := RecordStoreMockSetResultBatchParams{ctx, requestRecords}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetResultBatch.t.Errorf("RecordStoreMock.SetResultBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetResultBatch.SetResultBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSetResultBatch.t.Fatal("No results are set for the RecordStoreMock.SetResultBatch")
		}
		return (*mm_results).err
	}
	if mmSetResultBatch.funcSetResultBatch != nil {
		return mmSetResultBatch.funcSetResultBatch(ctx, requestRecords)
	}
	mmSetResultBatch.t.Fatalf("Unexpected call to RecordStoreMock.SetResultBatch. %v %v", ctx, requestRecords)
	return
}

// SetResultBatchAfterCounter returns a count of finished RecordStoreMock.SetResultBatch invocations
func (mmSetResultBatch *RecordStoreMock) SetResultBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetResultBatch.afterSetResultBatchCounter)
}

// SetResultBatchBeforeCounter returns a count of RecordStoreMock.SetResultBatch invocations
func (mmSetResultBatch *RecordStoreMock) SetResultBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetResultBatch.beforeSetResultBatchCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetResultBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetResultBatch *mRecordStoreMockSetResultBatch) Calls() []*RecordStoreMockSetResultBatchParams {
	mmSetResultBatch.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetResultBatchParams, len(mmSetResultBatch.callArgs))
	copy(argCopy, mmSetResultBatch.callArgs)

	mmSetResultBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSetResultBatchDone returns true if the count of the SetResultBatch invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetResultBatchDone() bool {
	for _, e := range m.SetResultBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetResultBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetResultBatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetResultBatch != nil && mm_atomic.LoadUint64(&m.afterSetResultBatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetResultBatchInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetResultBatchInspect() {
	for _, e := range m.SetResultBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetResultBatch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetResultBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetResultBatchCounter) < 1 {
		if m.SetResultBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetResultBatch")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetResultBatch with params: %#v", *m.SetResultBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetResultBatch != nil && mm_atomic.LoadUint64(&m.afterSetResultBatchCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetResultBatch")
	}
}

type mRecordStoreMockSetSideEffect struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetSideEffectExpectation
	expectations       []*RecordStoreMockSetSideEffectExpectation

	callArgs []*RecordStoreMockSetSideEffectParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetSideEffectExpectation specifies expectation struct of the RecordStore.SetSideEffect
type RecordStoreMockSetSideEffectExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetSideEffectParams
	results *RecordStoreMockSetSideEffectResults
	Counter uint64
}

// RecordStoreMockSetSideEffectParams contains parameters of the RecordStore.SetSideEffect
type RecordStoreMockSetSideEffectParams struct {
	ctx    context.Context
	record record.Material
}

// RecordStoreMockSetSideEffectResults contains results of the RecordStore.SetSideEffect
type RecordStoreMockSetSideEffectResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetSideEffect
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Expect(ctx context.Context, record record.Material) *mRecordStoreMockSetSideEffect {
	if mmSetSideEffect.mock.funcSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("RecordStoreMock.SetSideEffect mock is already set by Set")
	}

	if mmSetSideEffect.defaultExpectation == nil {
		mmSetSideEffect.defaultExpectation = &RecordStoreMockSetSideEffectExpectation{}
	}

	mmSetSideEffect.defaultExpectation.params = &RecordStoreMockSetSideEffectParams{ctx, record}
	for _, e := range mmSetSideEffect.expectations {
		if minimock.Equal(e.params, mmSetSideEffect.defaultExpectation.params) {
			mmSetSideEffect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetSideEffect.defaultExpectation.params)
		}
	}

	return mmSetSideEffect
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetSideEffect
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Inspect(f func(ctx context.Context, record record.Material)) *mRecordStoreMockSetSideEffect {
	if mmSetSideEffect.mock.inspectFuncSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetSideEffect")
	}

	mmSetSideEffect.mock.inspectFuncSetSideEffect = f

	return mmSetSideEffect
}

// Return sets up results that will be returned by RecordStore.SetSideEffect
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Return(err error) *RecordStoreMock {
	if mmSetSideEffect.mock.funcSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("RecordStoreMock.SetSideEffect mock is already set by Set")
	}

	if mmSetSideEffect.defaultExpectation == nil {
		mmSetSideEffect.defaultExpectation = &RecordStoreMockSetSideEffectExpectation{mock: mmSetSideEffect.mock}
	}
	mmSetSideEffect.defaultExpectation.results = &RecordStoreMockSetSideEffectResults{err}
	return mmSetSideEffect.mock
}

//Set uses given function f to mock the RecordStore.SetSideEffect method
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Set(f func(ctx context.Context, record record.Material) (err error)) *RecordStoreMock {
	if mmSetSideEffect.defaultExpectation != nil {
		mmSetSideEffect.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetSideEffect method")
	}

	if len(mmSetSideEffect.expectations) > 0 {
		mmSetSideEffect.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetSideEffect method")
	}

	mmSetSideEffect.mock.funcSetSideEffect = f
	return mmSetSideEffect.mock
}

// When sets expectation for the RecordStore.SetSideEffect which will trigger the result defined by the following
// Then helper
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) When(ctx context.Context, record record.Material) *RecordStoreMockSetSideEffectExpectation {
	if mmSetSideEffect.mock.funcSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("RecordStoreMock.SetSideEffect mock is already set by Set")
	}

	expectation := &RecordStoreMockSetSideEffectExpectation{
		mock:   mmSetSideEffect.mock,
		params: &RecordStoreMockSetSideEffectParams{ctx, record},
	}
	mmSetSideEffect.expectations = append(mmSetSideEffect.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetSideEffect return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetSideEffectExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetSideEffectResults{err}
	return e.mock
}

// SetSideEffect implements RecordStore
func (mmSetSideEffect *RecordStoreMock) SetSideEffect(ctx context.Context, record record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetSideEffect.beforeSetSideEffectCounter, 1)
	defer mm_atomic.AddUint64(&mmSetSideEffect.afterSetSideEffectCounter, 1)

	if mmSetSideEffect.inspectFuncSetSideEffect != nil {
		mmSetSideEffect.inspectFuncSetSideEffect(ctx, record)
	}

	mm_params := &RecordStoreMockSetSideEffectParams{ctx, record}

	// Record call args
	mmSetSideEffect.SetSideEffectMock.mutex.Lock()
	mmSetSideEffect.SetSideEffectMock.callArgs = append(mmSetSideEffect.SetSideEffectMock.callArgs, mm_params)
	mmSetSideEffect.SetSideEffectMock.mutex.Unlock()

	for _, e := range mmSetSideEffect.SetSideEffectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetSideEffect.SetSideEffectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetSideEffect.SetSideEffectMock.defaultExpectation.Counter, 1)
		mm_want := mmSetSideEffect.SetSideEffectMock.defaultExpectation.params
		mm_got := RecordStoreMockSetSideEffectParams{ctx, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetSideEffect.t.Errorf("RecordStoreMock.SetSideEffect got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetSideEffect.SetSideEffectMock.defaultExpectation.results
		if mm_results == nil {
			mmSetSideEffect.t.Fatal("No results are set for the RecordStoreMock.SetSideEffect")
		}
		return (*mm_results).err
	}
	if mmSetSideEffect.funcSetSideEffect != nil {
		return mmSetSideEffect.funcSetSideEffect(ctx, record)
	}
	mmSetSideEffect.t.Fatalf("Unexpected call to RecordStoreMock.SetSideEffect. %v %v", ctx, record)
	return
}

// SetSideEffectAfterCounter returns a count of finished RecordStoreMock.SetSideEffect invocations
func (mmSetSideEffect *RecordStoreMock) SetSideEffectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSideEffect.afterSetSideEffectCounter)
}

// SetSideEffectBeforeCounter returns a count of RecordStoreMock.SetSideEffect invocations
func (mmSetSideEffect *RecordStoreMock) SetSideEffectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSideEffect.beforeSetSideEffectCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetSideEffect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Calls() []*RecordStoreMockSetSideEffectParams {
	mmSetSideEffect.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetSideEffectParams, len(mmSetSideEffect.callArgs))
	copy(argCopy, mmSetSideEffect.callArgs)

	mmSetSideEffect.mutex.RUnlock()

	return argCopy
}

// MinimockSetSideEffectDone returns true if the count of the SetSideEffect invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetSideEffectDone() bool {
	for _, e := range m.SetSideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSideEffect != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetSideEffectInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetSideEffectInspect() {
	for _, e := range m.SetSideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetSideEffect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		if m.SetSideEffectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetSideEffect")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetSideEffect with params: %#v", *m.SetSideEffectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSideEffect != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetSideEffect")
	}
}

type mRecordStoreMockSetSideEffectBatch struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetSideEffectBatchExpectation
	expectations       []*RecordStoreMockSetSideEffectBatchExpectation

	callArgs []*RecordStoreMockSetSideEffectBatchParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetSideEffectBatchExpectation specifies expectation struct of the RecordStore.SetSideEffectBatch
type RecordStoreMockSetSideEffectBatchExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetSideEffectBatchParams
	results *RecordStoreMockSetSideEffectBatchResults
	Counter uint64
}

// RecordStoreMockSetSideEffectBatchParams contains parameters of the RecordStore.SetSideEffectBatch
type RecordStoreMockSetSideEffectBatchParams struct {
	ctx            context.Context
	requestRecords []record.Material
}

// RecordStoreMockSetSideEffectBatchResults contains results of the RecordStore.SetSideEffectBatch
type RecordStoreMockSetSideEffectBatchResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetSideEffectBatch
func (mmSetSideEffectBatch *mRecordStoreMockSetSideEffectBatch) Expect(ctx context.Context, requestRecords []record.Material) *mRecordStoreMockSetSideEffectBatch {
	if mmSetSideEffectBatch.mock.funcSetSideEffectBatch != nil {
		mmSetSideEffectBatch.mock.t.Fatalf("RecordStoreMock.SetSideEffectBatch mock is already set by Set")
	}

	if mmSetSideEffectBatch.defaultExpectation == nil {
		mmSetSideEffectBatch.defaultExpectation = &RecordStoreMockSetSideEffectBatchExpectation{}
	}

	mmSetSideEffectBatch.defaultExpectation.params = &RecordStoreMockSetSideEffectBatchParams{ctx, requestRecords}
	for _, e := range mmSetSideEffectBatch.expectations {
		if minimock.Equal(e.params, mmSetSideEffectBatch.defaultExpectation.params) {
			mmSetSideEffectBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetSideEffectBatch.defaultExpectation.params)
		}
	}

	return mmSetSideEffectBatch
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetSideEffectBatch
func (mmSetSideEffectBatch *mRecordStoreMockSetSideEffectBatch) Inspect(f func(ctx context.Context, requestRecords []record.Material)) *mRecordStoreMockSetSideEffectBatch {
	if mmSetSideEffectBatch.mock.inspectFuncSetSideEffectBatch != nil {
		mmSetSideEffectBatch.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetSideEffectBatch")
	}

	mmSetSideEffectBatch.mock.inspectFuncSetSideEffectBatch = f

	return mmSetSideEffectBatch
}

// Return sets up results that will be returned by RecordStore.SetSideEffectBatch
func (mmSetSideEffectBatch *mRecordStoreMockSetSideEffectBatch) Return(err error) *RecordStoreMock {
	if mmSetSideEffectBatch.mock.funcSetSideEffectBatch != nil {
		mmSetSideEffectBatch.mock.t.Fatalf("RecordStoreMock.SetSideEffectBatch mock is already set by Set")
	}

	if mmSetSideEffectBatch.defaultExpectation == nil {
		mmSetSideEffectBatch.defaultExpectation = &RecordStoreMockSetSideEffectBatchExpectation{mock: mmSetSideEffectBatch.mock}
	}
	mmSetSideEffectBatch.defaultExpectation.results = &RecordStoreMockSetSideEffectBatchResults{err}
	return mmSetSideEffectBatch.mock
}

//Set uses given function f to mock the RecordStore.SetSideEffectBatch method
func (mmSetSideEffectBatch *mRecordStoreMockSetSideEffectBatch) Set(f func(ctx context.Context, requestRecords []record.Material) (err error)) *RecordStoreMock {
	if mmSetSideEffectBatch.defaultExpectation != nil {
		mmSetSideEffectBatch.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetSideEffectBatch method")
	}

	if len(mmSetSideEffectBatch.expectations) > 0 {
		mmSetSideEffectBatch.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetSideEffectBatch method")
	}

	mmSetSideEffectBatch.mock.funcSetSideEffectBatch = f
	return mmSetSideEffectBatch.mock
}

// When sets expectation for the RecordStore.SetSideEffectBatch which will trigger the result defined by the following
// Then helper
func (mmSetSideEffectBatch *mRecordStoreMockSetSideEffectBatch) When(ctx context.Context, requestRecords []record.Material) *RecordStoreMockSetSideEffectBatchExpectation {
	if mmSetSideEffectBatch.mock.funcSetSideEffectBatch != nil {
		mmSetSideEffectBatch.mock.t.Fatalf("RecordStoreMock.SetSideEffectBatch mock is already set by Set")
	}

	expectation := &RecordStoreMockSetSideEffectBatchExpectation{
		mock:   mmSetSideEffectBatch.mock,
		params: &RecordStoreMockSetSideEffectBatchParams{ctx, requestRecords},
	}
	mmSetSideEffectBatch.expectations = append(mmSetSideEffectBatch.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetSideEffectBatch return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetSideEffectBatchExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetSideEffectBatchResults{err}
	return e.mock
}

// SetSideEffectBatch implements RecordStore
func (mmSetSideEffectBatch *RecordStoreMock) SetSideEffectBatch(ctx context.Context, requestRecords []record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetSideEffectBatch.beforeSetSideEffectBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSetSideEffectBatch.afterSetSideEffectBatchCounter, 1)

	if mmSetSideEffectBatch.inspectFuncSetSideEffectBatch != nil {
		mmSetSideEffectBatch.inspectFuncSetSideEffectBatch(ctx, requestRecords)
	}

	mm_params := &RecordStoreMockSetSideEffectBatchParams{ctx, requestRecords}

	// Record call args
	mmSetSideEffectBatch.SetSideEffectBatchMock.mutex.Lock()
	mmSetSideEffectBatch.SetSideEffectBatchMock.callArgs = append(mmSetSideEffectBatch.SetSideEffectBatchMock.callArgs, mm_params)
	mmSetSideEffectBatch.SetSideEffectBatchMock.mutex.Unlock()

	for _, e := range mmSetSideEffectBatch.SetSideEffectBatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetSideEffectBatch.SetSideEffectBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetSideEffectBatch.SetSideEffectBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSetSideEffectBatch.SetSideEffectBatchMock.defaultExpectation.params
		mm_got := RecordStoreMockSetSideEffectBatchParams{ctx, requestRecords}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetSideEffectBatch.t.Errorf("RecordStoreMock.SetSideEffectBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetSideEffectBatch.SetSideEffectBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSetSideEffectBatch.t.Fatal("No results are set for the RecordStoreMock.SetSideEffectBatch")
		}
		return (*mm_results).err
	}
	if mmSetSideEffectBatch.funcSetSideEffectBatch != nil {
		return mmSetSideEffectBatch.funcSetSideEffectBatch(ctx, requestRecords)
	}
	mmSetSideEffectBatch.t.Fatalf("Unexpected call to RecordStoreMock.SetSideEffectBatch. %v %v", ctx, requestRecords)
	return
}

// SetSideEffectBatchAfterCounter returns a count of finished RecordStoreMock.SetSideEffectBatch invocations
func (mmSetSideEffectBatch *RecordStoreMock) SetSideEffectBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSideEffectBatch.afterSetSideEffectBatchCounter)
}

// SetSideEffectBatchBeforeCounter returns a count of RecordStoreMock.SetSideEffectBatch invocations
func (mmSetSideEffectBatch *RecordStoreMock) SetSideEffectBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSideEffectBatch.beforeSetSideEffectBatchCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetSideEffectBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetSideEffectBatch *mRecordStoreMockSetSideEffectBatch) Calls() []*RecordStoreMockSetSideEffectBatchParams {
	mmSetSideEffectBatch.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetSideEffectBatchParams, len(mmSetSideEffectBatch.callArgs))
	copy(argCopy, mmSetSideEffectBatch.callArgs)

	mmSetSideEffectBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSetSideEffectBatchDone returns true if the count of the SetSideEffectBatch invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetSideEffectBatchDone() bool {
	for _, e := range m.SetSideEffectBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSideEffectBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectBatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSideEffectBatch != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectBatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetSideEffectBatchInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetSideEffectBatchInspect() {
	for _, e := range m.SetSideEffectBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetSideEffectBatch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSideEffectBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectBatchCounter) < 1 {
		if m.SetSideEffectBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetSideEffectBatch")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetSideEffectBatch with params: %#v", *m.SetSideEffectBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSideEffectBatch != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectBatchCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetSideEffectBatch")
	}
}

type mRecordStoreMockSideEffect struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSideEffectExpectation
	expectations       []*RecordStoreMockSideEffectExpectation

	callArgs []*RecordStoreMockSideEffectParams
	mutex    sync.RWMutex
}

// RecordStoreMockSideEffectExpectation specifies expectation struct of the RecordStore.SideEffect
type RecordStoreMockSideEffectExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSideEffectParams
	results *RecordStoreMockSideEffectResults
	Counter uint64
}

// RecordStoreMockSideEffectParams contains parameters of the RecordStore.SideEffect
type RecordStoreMockSideEffectParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockSideEffectResults contains results of the RecordStore.SideEffect
type RecordStoreMockSideEffectResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordStore.SideEffect
func (mmSideEffect *mRecordStoreMockSideEffect) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockSideEffect {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordStoreMock.SideEffect mock is already set by Set")
	}

	if mmSideEffect.defaultExpectation == nil {
		mmSideEffect.defaultExpectation = &RecordStoreMockSideEffectExpectation{}
	}

	mmSideEffect.defaultExpectation.params = &RecordStoreMockSideEffectParams{ctx, reqID}
	for _, e := range mmSideEffect.expectations {
		if minimock.Equal(e.params, mmSideEffect.defaultExpectation.params) {
			mmSideEffect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSideEffect.defaultExpectation.params)
		}
	}

	return mmSideEffect
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SideEffect
func (mmSideEffect *mRecordStoreMockSideEffect) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockSideEffect {
	if mmSideEffect.mock.inspectFuncSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SideEffect")
	}

	mmSideEffect.mock.inspectFuncSideEffect = f

	return mmSideEffect
}

// Return sets up results that will be returned by RecordStore.SideEffect
func (mmSideEffect *mRecordStoreMockSideEffect) Return(m1 record.Material, err error) *RecordStoreMock {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordStoreMock.SideEffect mock is already set by Set")
	}

	if mmSideEffect.defaultExpectation == nil {
		mmSideEffect.defaultExpectation = &RecordStoreMockSideEffectExpectation{mock: mmSideEffect.mock}
	}
	mmSideEffect.defaultExpectation.results = &RecordStoreMockSideEffectResults{m1, err}
	return mmSideEffect.mock
}

//Set uses given function f to mock the RecordStore.SideEffect method
func (mmSideEffect *mRecordStoreMockSideEffect) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordStoreMock {
	if mmSideEffect.defaultExpectation != nil {
		mmSideEffect.mock.t.Fatalf("Default expectation is already set for the RecordStore.SideEffect method")
	}

	if len(mmSideEffect.expectations) > 0 {
		mmSideEffect.mock.t.Fatalf("Some expectations are already set for the RecordStore.SideEffect method")
	}

	mmSideEffect.mock.funcSideEffect = f
	return mmSideEffect.mock
}

// When sets expectation for the RecordStore.SideEffect which will trigger the result defined by the following
// Then helper
func (mmSideEffect *mRecordStoreMockSideEffect) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockSideEffectExpectation {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordStoreMock.SideEffect mock is already set by Set")
	}

	expectation := &RecordStoreMockSideEffectExpectation{
		mock:   mmSideEffect.mock,
		params: &RecordStoreMockSideEffectParams{ctx, reqID},
	}
	mmSideEffect.expectations = append(mmSideEffect.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SideEffect return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSideEffectExpectation) Then(m1 record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockSideEffectResults{m1, err}
	return e.mock
}

// SideEffect implements RecordStore
func (mmSideEffect *RecordStoreMock) SideEffect(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmSideEffect.beforeSideEffectCounter, 1)
	defer mm_atomic.AddUint64(&mmSideEffect.afterSideEffectCounter, 1)

	if mmSideEffect.inspectFuncSideEffect != nil {
		mmSideEffect.inspectFuncSideEffect(ctx, reqID)
	}

	mm_params := &RecordStoreMockSideEffectParams{ctx, reqID}

	// Record call args
	mmSideEffect.SideEffectMock.mutex.Lock()
	mmSideEffect.SideEffectMock.callArgs = append(mmSideEffect.SideEffectMock.callArgs, mm_params)
	mmSideEffect.SideEffectMock.mutex.Unlock()

	for _, e := range mmSideEffect.SideEffectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmSideEffect.SideEffectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSideEffect.SideEffectMock.defaultExpectation.Counter, 1)
		mm_want := mmSideEffect.SideEffectMock.defaultExpectation.params
		mm_got := RecordStoreMockSideEffectParams{ctx, reqID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSideEffect.t.Errorf("RecordStoreMock.SideEffect got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSideEffect.SideEffectMock.defaultExpectation.results
		if mm_results == nil {
			mmSideEffect.t.Fatal("No results are set for the RecordStoreMock.SideEffect")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmSideEffect.funcSideEffect != nil {
		return mmSideEffect.funcSideEffect(ctx, reqID)
	}
	mmSideEffect.t.Fatalf("Unexpected call to RecordStoreMock.SideEffect. %v %v", ctx, reqID)
	return
}

// SideEffectAfterCounter returns a count of finished RecordStoreMock.SideEffect invocations
func (mmSideEffect *RecordStoreMock) SideEffectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSideEffect.afterSideEffectCounter)
}

// SideEffectBeforeCounter returns a count of RecordStoreMock.SideEffect invocations
func (mmSideEffect *RecordStoreMock) SideEffectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSideEffect.beforeSideEffectCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SideEffect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSideEffect *mRecordStoreMockSideEffect) Calls() []*RecordStoreMockSideEffectParams {
	mmSideEffect.mutex.RLock()

	argCopy := make([]*RecordStoreMockSideEffectParams, len(mmSideEffect.callArgs))
	copy(argCopy, mmSideEffect.callArgs)

	mmSideEffect.mutex.RUnlock()

	return argCopy
}

// MinimockSideEffectDone returns true if the count of the SideEffect invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSideEffectDone() bool {
	for _, e := range m.SideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSideEffect != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSideEffectInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSideEffectInspect() {
	for _, e := range m.SideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SideEffect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		if m.SideEffectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SideEffect")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SideEffect with params: %#v", *m.SideEffectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSideEffect != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SideEffect")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RecordStoreMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCalledRequestsInspect()

		m.MinimockFlushInspect()

		m.MinimockRequestInspect()

		m.MinimockResultInspect()

		m.MinimockSetRequestInspect()

		m.MinimockSetRequestBatchInspect()

		m.MinimockSetResultInspect()

		m.MinimockSetResultBatchInspect()

		m.MinimockSetSideEffectInspect()

		m.MinimockSetSideEffectBatchInspect()

		m.MinimockSideEffectInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RecordStoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RecordStoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCalledRequestsDone() &&
		m.MinimockFlushDone() &&
		m.MinimockRequestDone() &&
		m.MinimockResultDone() &&
		m.MinimockSetRequestDone() &&
		m.MinimockSetRequestBatchDone() &&
		m.MinimockSetResultDone() &&
		m.MinimockSetResultBatchDone() &&
		m.MinimockSetSideEffectDone() &&
		m.MinimockSetSideEffectBatchDone() &&
		m.MinimockSideEffectDone()
}
