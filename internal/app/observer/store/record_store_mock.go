package store

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/insolar/record"
)

// RecordStoreMock implements RecordStore
type RecordStoreMock struct {
	t minimock.Tester

	funcCalledRequests          func(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error)
	inspectFuncCalledRequests   func(ctx context.Context, reqID insolar.ID)
	afterCalledRequestsCounter  uint64
	beforeCalledRequestsCounter uint64
	CalledRequestsMock          mRecordStoreMockCalledRequests

	funcRequest          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncRequest   func(ctx context.Context, reqID insolar.ID)
	afterRequestCounter  uint64
	beforeRequestCounter uint64
	RequestMock          mRecordStoreMockRequest

	funcResult          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncResult   func(ctx context.Context, reqID insolar.ID)
	afterResultCounter  uint64
	beforeResultCounter uint64
	ResultMock          mRecordStoreMockResult

	funcSetRequest          func(ctx context.Context, record record.Material) (err error)
	inspectFuncSetRequest   func(ctx context.Context, record record.Material)
	afterSetRequestCounter  uint64
	beforeSetRequestCounter uint64
	SetRequestMock          mRecordStoreMockSetRequest

	funcSetResult          func(ctx context.Context, record record.Material) (err error)
	inspectFuncSetResult   func(ctx context.Context, record record.Material)
	afterSetResultCounter  uint64
	beforeSetResultCounter uint64
	SetResultMock          mRecordStoreMockSetResult

	funcSetSideEffect          func(ctx context.Context, record record.Material) (err error)
	inspectFuncSetSideEffect   func(ctx context.Context, record record.Material)
	afterSetSideEffectCounter  uint64
	beforeSetSideEffectCounter uint64
	SetSideEffectMock          mRecordStoreMockSetSideEffect

	funcSideEffect          func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)
	inspectFuncSideEffect   func(ctx context.Context, reqID insolar.ID)
	afterSideEffectCounter  uint64
	beforeSideEffectCounter uint64
	SideEffectMock          mRecordStoreMockSideEffect
}

// NewRecordStoreMock returns a mock for RecordStore
func NewRecordStoreMock(t minimock.Tester) *RecordStoreMock {
	m := &RecordStoreMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CalledRequestsMock = mRecordStoreMockCalledRequests{mock: m}
	m.CalledRequestsMock.callArgs = []*RecordStoreMockCalledRequestsParams{}

	m.RequestMock = mRecordStoreMockRequest{mock: m}
	m.RequestMock.callArgs = []*RecordStoreMockRequestParams{}

	m.ResultMock = mRecordStoreMockResult{mock: m}
	m.ResultMock.callArgs = []*RecordStoreMockResultParams{}

	m.SetRequestMock = mRecordStoreMockSetRequest{mock: m}
	m.SetRequestMock.callArgs = []*RecordStoreMockSetRequestParams{}

	m.SetResultMock = mRecordStoreMockSetResult{mock: m}
	m.SetResultMock.callArgs = []*RecordStoreMockSetResultParams{}

	m.SetSideEffectMock = mRecordStoreMockSetSideEffect{mock: m}
	m.SetSideEffectMock.callArgs = []*RecordStoreMockSetSideEffectParams{}

	m.SideEffectMock = mRecordStoreMockSideEffect{mock: m}
	m.SideEffectMock.callArgs = []*RecordStoreMockSideEffectParams{}

	return m
}

type mRecordStoreMockCalledRequests struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockCalledRequestsExpectation
	expectations       []*RecordStoreMockCalledRequestsExpectation

	callArgs []*RecordStoreMockCalledRequestsParams
	mutex    sync.RWMutex
}

// RecordStoreMockCalledRequestsExpectation specifies expectation struct of the RecordStore.CalledRequests
type RecordStoreMockCalledRequestsExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockCalledRequestsParams
	results *RecordStoreMockCalledRequestsResults
	Counter uint64
}

// RecordStoreMockCalledRequestsParams contains parameters of the RecordStore.CalledRequests
type RecordStoreMockCalledRequestsParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockCalledRequestsResults contains results of the RecordStore.CalledRequests
type RecordStoreMockCalledRequestsResults struct {
	ma1 []record.Material
	err error
}

// Expect sets up expected params for RecordStore.CalledRequests
func (mmCalledRequests *mRecordStoreMockCalledRequests) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockCalledRequests {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordStoreMock.CalledRequests mock is already set by Set")
	}

	if mmCalledRequests.defaultExpectation == nil {
		mmCalledRequests.defaultExpectation = &RecordStoreMockCalledRequestsExpectation{}
	}

	mmCalledRequests.defaultExpectation.params = &RecordStoreMockCalledRequestsParams{ctx, reqID}
	for _, e := range mmCalledRequests.expectations {
		if minimock.Equal(e.params, mmCalledRequests.defaultExpectation.params) {
			mmCalledRequests.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCalledRequests.defaultExpectation.params)
		}
	}

	return mmCalledRequests
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.CalledRequests
func (mmCalledRequests *mRecordStoreMockCalledRequests) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockCalledRequests {
	if mmCalledRequests.mock.inspectFuncCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.CalledRequests")
	}

	mmCalledRequests.mock.inspectFuncCalledRequests = f

	return mmCalledRequests
}

// Return sets up results that will be returned by RecordStore.CalledRequests
func (mmCalledRequests *mRecordStoreMockCalledRequests) Return(ma1 []record.Material, err error) *RecordStoreMock {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordStoreMock.CalledRequests mock is already set by Set")
	}

	if mmCalledRequests.defaultExpectation == nil {
		mmCalledRequests.defaultExpectation = &RecordStoreMockCalledRequestsExpectation{mock: mmCalledRequests.mock}
	}
	mmCalledRequests.defaultExpectation.results = &RecordStoreMockCalledRequestsResults{ma1, err}
	return mmCalledRequests.mock
}

//Set uses given function f to mock the RecordStore.CalledRequests method
func (mmCalledRequests *mRecordStoreMockCalledRequests) Set(f func(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error)) *RecordStoreMock {
	if mmCalledRequests.defaultExpectation != nil {
		mmCalledRequests.mock.t.Fatalf("Default expectation is already set for the RecordStore.CalledRequests method")
	}

	if len(mmCalledRequests.expectations) > 0 {
		mmCalledRequests.mock.t.Fatalf("Some expectations are already set for the RecordStore.CalledRequests method")
	}

	mmCalledRequests.mock.funcCalledRequests = f
	return mmCalledRequests.mock
}

// When sets expectation for the RecordStore.CalledRequests which will trigger the result defined by the following
// Then helper
func (mmCalledRequests *mRecordStoreMockCalledRequests) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockCalledRequestsExpectation {
	if mmCalledRequests.mock.funcCalledRequests != nil {
		mmCalledRequests.mock.t.Fatalf("RecordStoreMock.CalledRequests mock is already set by Set")
	}

	expectation := &RecordStoreMockCalledRequestsExpectation{
		mock:   mmCalledRequests.mock,
		params: &RecordStoreMockCalledRequestsParams{ctx, reqID},
	}
	mmCalledRequests.expectations = append(mmCalledRequests.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.CalledRequests return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockCalledRequestsExpectation) Then(ma1 []record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockCalledRequestsResults{ma1, err}
	return e.mock
}

// CalledRequests implements RecordStore
func (mmCalledRequests *RecordStoreMock) CalledRequests(ctx context.Context, reqID insolar.ID) (ma1 []record.Material, err error) {
	mm_atomic.AddUint64(&mmCalledRequests.beforeCalledRequestsCounter, 1)
	defer mm_atomic.AddUint64(&mmCalledRequests.afterCalledRequestsCounter, 1)

	if mmCalledRequests.inspectFuncCalledRequests != nil {
		mmCalledRequests.inspectFuncCalledRequests(ctx, reqID)
	}

	params := &RecordStoreMockCalledRequestsParams{ctx, reqID}

	// Record call args
	mmCalledRequests.CalledRequestsMock.mutex.Lock()
	mmCalledRequests.CalledRequestsMock.callArgs = append(mmCalledRequests.CalledRequestsMock.callArgs, params)
	mmCalledRequests.CalledRequestsMock.mutex.Unlock()

	for _, e := range mmCalledRequests.CalledRequestsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmCalledRequests.CalledRequestsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCalledRequests.CalledRequestsMock.defaultExpectation.Counter, 1)
		want := mmCalledRequests.CalledRequestsMock.defaultExpectation.params
		got := RecordStoreMockCalledRequestsParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmCalledRequests.t.Errorf("RecordStoreMock.CalledRequests got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCalledRequests.CalledRequestsMock.defaultExpectation.results
		if results == nil {
			mmCalledRequests.t.Fatal("No results are set for the RecordStoreMock.CalledRequests")
		}
		return (*results).ma1, (*results).err
	}
	if mmCalledRequests.funcCalledRequests != nil {
		return mmCalledRequests.funcCalledRequests(ctx, reqID)
	}
	mmCalledRequests.t.Fatalf("Unexpected call to RecordStoreMock.CalledRequests. %v %v", ctx, reqID)
	return
}

// CalledRequestsAfterCounter returns a count of finished RecordStoreMock.CalledRequests invocations
func (mmCalledRequests *RecordStoreMock) CalledRequestsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalledRequests.afterCalledRequestsCounter)
}

// CalledRequestsBeforeCounter returns a count of RecordStoreMock.CalledRequests invocations
func (mmCalledRequests *RecordStoreMock) CalledRequestsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalledRequests.beforeCalledRequestsCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.CalledRequests.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCalledRequests *mRecordStoreMockCalledRequests) Calls() []*RecordStoreMockCalledRequestsParams {
	mmCalledRequests.mutex.RLock()

	argCopy := make([]*RecordStoreMockCalledRequestsParams, len(mmCalledRequests.callArgs))
	copy(argCopy, mmCalledRequests.callArgs)

	mmCalledRequests.mutex.RUnlock()

	return argCopy
}

// MinimockCalledRequestsDone returns true if the count of the CalledRequests invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockCalledRequestsDone() bool {
	for _, e := range m.CalledRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalledRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalledRequests != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCalledRequestsInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockCalledRequestsInspect() {
	for _, e := range m.CalledRequestsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.CalledRequests with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalledRequestsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		if m.CalledRequestsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.CalledRequests")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.CalledRequests with params: %#v", *m.CalledRequestsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalledRequests != nil && mm_atomic.LoadUint64(&m.afterCalledRequestsCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.CalledRequests")
	}
}

type mRecordStoreMockRequest struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockRequestExpectation
	expectations       []*RecordStoreMockRequestExpectation

	callArgs []*RecordStoreMockRequestParams
	mutex    sync.RWMutex
}

// RecordStoreMockRequestExpectation specifies expectation struct of the RecordStore.Request
type RecordStoreMockRequestExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockRequestParams
	results *RecordStoreMockRequestResults
	Counter uint64
}

// RecordStoreMockRequestParams contains parameters of the RecordStore.Request
type RecordStoreMockRequestParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockRequestResults contains results of the RecordStore.Request
type RecordStoreMockRequestResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordStore.Request
func (mmRequest *mRecordStoreMockRequest) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockRequest {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordStoreMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &RecordStoreMockRequestExpectation{}
	}

	mmRequest.defaultExpectation.params = &RecordStoreMockRequestParams{ctx, reqID}
	for _, e := range mmRequest.expectations {
		if minimock.Equal(e.params, mmRequest.defaultExpectation.params) {
			mmRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequest.defaultExpectation.params)
		}
	}

	return mmRequest
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.Request
func (mmRequest *mRecordStoreMockRequest) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockRequest {
	if mmRequest.mock.inspectFuncRequest != nil {
		mmRequest.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.Request")
	}

	mmRequest.mock.inspectFuncRequest = f

	return mmRequest
}

// Return sets up results that will be returned by RecordStore.Request
func (mmRequest *mRecordStoreMockRequest) Return(m1 record.Material, err error) *RecordStoreMock {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordStoreMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &RecordStoreMockRequestExpectation{mock: mmRequest.mock}
	}
	mmRequest.defaultExpectation.results = &RecordStoreMockRequestResults{m1, err}
	return mmRequest.mock
}

//Set uses given function f to mock the RecordStore.Request method
func (mmRequest *mRecordStoreMockRequest) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordStoreMock {
	if mmRequest.defaultExpectation != nil {
		mmRequest.mock.t.Fatalf("Default expectation is already set for the RecordStore.Request method")
	}

	if len(mmRequest.expectations) > 0 {
		mmRequest.mock.t.Fatalf("Some expectations are already set for the RecordStore.Request method")
	}

	mmRequest.mock.funcRequest = f
	return mmRequest.mock
}

// When sets expectation for the RecordStore.Request which will trigger the result defined by the following
// Then helper
func (mmRequest *mRecordStoreMockRequest) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockRequestExpectation {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("RecordStoreMock.Request mock is already set by Set")
	}

	expectation := &RecordStoreMockRequestExpectation{
		mock:   mmRequest.mock,
		params: &RecordStoreMockRequestParams{ctx, reqID},
	}
	mmRequest.expectations = append(mmRequest.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.Request return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockRequestExpectation) Then(m1 record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockRequestResults{m1, err}
	return e.mock
}

// Request implements RecordStore
func (mmRequest *RecordStoreMock) Request(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmRequest.beforeRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRequest.afterRequestCounter, 1)

	if mmRequest.inspectFuncRequest != nil {
		mmRequest.inspectFuncRequest(ctx, reqID)
	}

	params := &RecordStoreMockRequestParams{ctx, reqID}

	// Record call args
	mmRequest.RequestMock.mutex.Lock()
	mmRequest.RequestMock.callArgs = append(mmRequest.RequestMock.callArgs, params)
	mmRequest.RequestMock.mutex.Unlock()

	for _, e := range mmRequest.RequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmRequest.RequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequest.RequestMock.defaultExpectation.Counter, 1)
		want := mmRequest.RequestMock.defaultExpectation.params
		got := RecordStoreMockRequestParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmRequest.t.Errorf("RecordStoreMock.Request got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRequest.RequestMock.defaultExpectation.results
		if results == nil {
			mmRequest.t.Fatal("No results are set for the RecordStoreMock.Request")
		}
		return (*results).m1, (*results).err
	}
	if mmRequest.funcRequest != nil {
		return mmRequest.funcRequest(ctx, reqID)
	}
	mmRequest.t.Fatalf("Unexpected call to RecordStoreMock.Request. %v %v", ctx, reqID)
	return
}

// RequestAfterCounter returns a count of finished RecordStoreMock.Request invocations
func (mmRequest *RecordStoreMock) RequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.afterRequestCounter)
}

// RequestBeforeCounter returns a count of RecordStoreMock.Request invocations
func (mmRequest *RecordStoreMock) RequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.beforeRequestCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.Request.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequest *mRecordStoreMockRequest) Calls() []*RecordStoreMockRequestParams {
	mmRequest.mutex.RLock()

	argCopy := make([]*RecordStoreMockRequestParams, len(mmRequest.callArgs))
	copy(argCopy, mmRequest.callArgs)

	mmRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRequestDone returns true if the count of the Request invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockRequestDone() bool {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockRequestInspect() {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.Request with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		if m.RequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.Request")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.Request with params: %#v", *m.RequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.Request")
	}
}

type mRecordStoreMockResult struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockResultExpectation
	expectations       []*RecordStoreMockResultExpectation

	callArgs []*RecordStoreMockResultParams
	mutex    sync.RWMutex
}

// RecordStoreMockResultExpectation specifies expectation struct of the RecordStore.Result
type RecordStoreMockResultExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockResultParams
	results *RecordStoreMockResultResults
	Counter uint64
}

// RecordStoreMockResultParams contains parameters of the RecordStore.Result
type RecordStoreMockResultParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockResultResults contains results of the RecordStore.Result
type RecordStoreMockResultResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordStore.Result
func (mmResult *mRecordStoreMockResult) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockResult {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordStoreMock.Result mock is already set by Set")
	}

	if mmResult.defaultExpectation == nil {
		mmResult.defaultExpectation = &RecordStoreMockResultExpectation{}
	}

	mmResult.defaultExpectation.params = &RecordStoreMockResultParams{ctx, reqID}
	for _, e := range mmResult.expectations {
		if minimock.Equal(e.params, mmResult.defaultExpectation.params) {
			mmResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResult.defaultExpectation.params)
		}
	}

	return mmResult
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.Result
func (mmResult *mRecordStoreMockResult) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockResult {
	if mmResult.mock.inspectFuncResult != nil {
		mmResult.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.Result")
	}

	mmResult.mock.inspectFuncResult = f

	return mmResult
}

// Return sets up results that will be returned by RecordStore.Result
func (mmResult *mRecordStoreMockResult) Return(m1 record.Material, err error) *RecordStoreMock {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordStoreMock.Result mock is already set by Set")
	}

	if mmResult.defaultExpectation == nil {
		mmResult.defaultExpectation = &RecordStoreMockResultExpectation{mock: mmResult.mock}
	}
	mmResult.defaultExpectation.results = &RecordStoreMockResultResults{m1, err}
	return mmResult.mock
}

//Set uses given function f to mock the RecordStore.Result method
func (mmResult *mRecordStoreMockResult) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordStoreMock {
	if mmResult.defaultExpectation != nil {
		mmResult.mock.t.Fatalf("Default expectation is already set for the RecordStore.Result method")
	}

	if len(mmResult.expectations) > 0 {
		mmResult.mock.t.Fatalf("Some expectations are already set for the RecordStore.Result method")
	}

	mmResult.mock.funcResult = f
	return mmResult.mock
}

// When sets expectation for the RecordStore.Result which will trigger the result defined by the following
// Then helper
func (mmResult *mRecordStoreMockResult) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockResultExpectation {
	if mmResult.mock.funcResult != nil {
		mmResult.mock.t.Fatalf("RecordStoreMock.Result mock is already set by Set")
	}

	expectation := &RecordStoreMockResultExpectation{
		mock:   mmResult.mock,
		params: &RecordStoreMockResultParams{ctx, reqID},
	}
	mmResult.expectations = append(mmResult.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.Result return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockResultExpectation) Then(m1 record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockResultResults{m1, err}
	return e.mock
}

// Result implements RecordStore
func (mmResult *RecordStoreMock) Result(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmResult.beforeResultCounter, 1)
	defer mm_atomic.AddUint64(&mmResult.afterResultCounter, 1)

	if mmResult.inspectFuncResult != nil {
		mmResult.inspectFuncResult(ctx, reqID)
	}

	params := &RecordStoreMockResultParams{ctx, reqID}

	// Record call args
	mmResult.ResultMock.mutex.Lock()
	mmResult.ResultMock.callArgs = append(mmResult.ResultMock.callArgs, params)
	mmResult.ResultMock.mutex.Unlock()

	for _, e := range mmResult.ResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmResult.ResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResult.ResultMock.defaultExpectation.Counter, 1)
		want := mmResult.ResultMock.defaultExpectation.params
		got := RecordStoreMockResultParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmResult.t.Errorf("RecordStoreMock.Result got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmResult.ResultMock.defaultExpectation.results
		if results == nil {
			mmResult.t.Fatal("No results are set for the RecordStoreMock.Result")
		}
		return (*results).m1, (*results).err
	}
	if mmResult.funcResult != nil {
		return mmResult.funcResult(ctx, reqID)
	}
	mmResult.t.Fatalf("Unexpected call to RecordStoreMock.Result. %v %v", ctx, reqID)
	return
}

// ResultAfterCounter returns a count of finished RecordStoreMock.Result invocations
func (mmResult *RecordStoreMock) ResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResult.afterResultCounter)
}

// ResultBeforeCounter returns a count of RecordStoreMock.Result invocations
func (mmResult *RecordStoreMock) ResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResult.beforeResultCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.Result.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResult *mRecordStoreMockResult) Calls() []*RecordStoreMockResultParams {
	mmResult.mutex.RLock()

	argCopy := make([]*RecordStoreMockResultParams, len(mmResult.callArgs))
	copy(argCopy, mmResult.callArgs)

	mmResult.mutex.RUnlock()

	return argCopy
}

// MinimockResultDone returns true if the count of the Result invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockResultDone() bool {
	for _, e := range m.ResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResult != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockResultInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockResultInspect() {
	for _, e := range m.ResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.Result with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		if m.ResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.Result")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.Result with params: %#v", *m.ResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResult != nil && mm_atomic.LoadUint64(&m.afterResultCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.Result")
	}
}

type mRecordStoreMockSetRequest struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetRequestExpectation
	expectations       []*RecordStoreMockSetRequestExpectation

	callArgs []*RecordStoreMockSetRequestParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetRequestExpectation specifies expectation struct of the RecordStore.SetRequest
type RecordStoreMockSetRequestExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetRequestParams
	results *RecordStoreMockSetRequestResults
	Counter uint64
}

// RecordStoreMockSetRequestParams contains parameters of the RecordStore.SetRequest
type RecordStoreMockSetRequestParams struct {
	ctx    context.Context
	record record.Material
}

// RecordStoreMockSetRequestResults contains results of the RecordStore.SetRequest
type RecordStoreMockSetRequestResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetRequest
func (mmSetRequest *mRecordStoreMockSetRequest) Expect(ctx context.Context, record record.Material) *mRecordStoreMockSetRequest {
	if mmSetRequest.mock.funcSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("RecordStoreMock.SetRequest mock is already set by Set")
	}

	if mmSetRequest.defaultExpectation == nil {
		mmSetRequest.defaultExpectation = &RecordStoreMockSetRequestExpectation{}
	}

	mmSetRequest.defaultExpectation.params = &RecordStoreMockSetRequestParams{ctx, record}
	for _, e := range mmSetRequest.expectations {
		if minimock.Equal(e.params, mmSetRequest.defaultExpectation.params) {
			mmSetRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetRequest.defaultExpectation.params)
		}
	}

	return mmSetRequest
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetRequest
func (mmSetRequest *mRecordStoreMockSetRequest) Inspect(f func(ctx context.Context, record record.Material)) *mRecordStoreMockSetRequest {
	if mmSetRequest.mock.inspectFuncSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetRequest")
	}

	mmSetRequest.mock.inspectFuncSetRequest = f

	return mmSetRequest
}

// Return sets up results that will be returned by RecordStore.SetRequest
func (mmSetRequest *mRecordStoreMockSetRequest) Return(err error) *RecordStoreMock {
	if mmSetRequest.mock.funcSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("RecordStoreMock.SetRequest mock is already set by Set")
	}

	if mmSetRequest.defaultExpectation == nil {
		mmSetRequest.defaultExpectation = &RecordStoreMockSetRequestExpectation{mock: mmSetRequest.mock}
	}
	mmSetRequest.defaultExpectation.results = &RecordStoreMockSetRequestResults{err}
	return mmSetRequest.mock
}

//Set uses given function f to mock the RecordStore.SetRequest method
func (mmSetRequest *mRecordStoreMockSetRequest) Set(f func(ctx context.Context, record record.Material) (err error)) *RecordStoreMock {
	if mmSetRequest.defaultExpectation != nil {
		mmSetRequest.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetRequest method")
	}

	if len(mmSetRequest.expectations) > 0 {
		mmSetRequest.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetRequest method")
	}

	mmSetRequest.mock.funcSetRequest = f
	return mmSetRequest.mock
}

// When sets expectation for the RecordStore.SetRequest which will trigger the result defined by the following
// Then helper
func (mmSetRequest *mRecordStoreMockSetRequest) When(ctx context.Context, record record.Material) *RecordStoreMockSetRequestExpectation {
	if mmSetRequest.mock.funcSetRequest != nil {
		mmSetRequest.mock.t.Fatalf("RecordStoreMock.SetRequest mock is already set by Set")
	}

	expectation := &RecordStoreMockSetRequestExpectation{
		mock:   mmSetRequest.mock,
		params: &RecordStoreMockSetRequestParams{ctx, record},
	}
	mmSetRequest.expectations = append(mmSetRequest.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetRequest return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetRequestExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetRequestResults{err}
	return e.mock
}

// SetRequest implements RecordStore
func (mmSetRequest *RecordStoreMock) SetRequest(ctx context.Context, record record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetRequest.beforeSetRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmSetRequest.afterSetRequestCounter, 1)

	if mmSetRequest.inspectFuncSetRequest != nil {
		mmSetRequest.inspectFuncSetRequest(ctx, record)
	}

	params := &RecordStoreMockSetRequestParams{ctx, record}

	// Record call args
	mmSetRequest.SetRequestMock.mutex.Lock()
	mmSetRequest.SetRequestMock.callArgs = append(mmSetRequest.SetRequestMock.callArgs, params)
	mmSetRequest.SetRequestMock.mutex.Unlock()

	for _, e := range mmSetRequest.SetRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetRequest.SetRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetRequest.SetRequestMock.defaultExpectation.Counter, 1)
		want := mmSetRequest.SetRequestMock.defaultExpectation.params
		got := RecordStoreMockSetRequestParams{ctx, record}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetRequest.t.Errorf("RecordStoreMock.SetRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSetRequest.SetRequestMock.defaultExpectation.results
		if results == nil {
			mmSetRequest.t.Fatal("No results are set for the RecordStoreMock.SetRequest")
		}
		return (*results).err
	}
	if mmSetRequest.funcSetRequest != nil {
		return mmSetRequest.funcSetRequest(ctx, record)
	}
	mmSetRequest.t.Fatalf("Unexpected call to RecordStoreMock.SetRequest. %v %v", ctx, record)
	return
}

// SetRequestAfterCounter returns a count of finished RecordStoreMock.SetRequest invocations
func (mmSetRequest *RecordStoreMock) SetRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRequest.afterSetRequestCounter)
}

// SetRequestBeforeCounter returns a count of RecordStoreMock.SetRequest invocations
func (mmSetRequest *RecordStoreMock) SetRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetRequest.beforeSetRequestCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetRequest *mRecordStoreMockSetRequest) Calls() []*RecordStoreMockSetRequestParams {
	mmSetRequest.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetRequestParams, len(mmSetRequest.callArgs))
	copy(argCopy, mmSetRequest.callArgs)

	mmSetRequest.mutex.RUnlock()

	return argCopy
}

// MinimockSetRequestDone returns true if the count of the SetRequest invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetRequestDone() bool {
	for _, e := range m.SetRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRequest != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetRequestInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetRequestInspect() {
	for _, e := range m.SetRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		if m.SetRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetRequest")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetRequest with params: %#v", *m.SetRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetRequest != nil && mm_atomic.LoadUint64(&m.afterSetRequestCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetRequest")
	}
}

type mRecordStoreMockSetResult struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetResultExpectation
	expectations       []*RecordStoreMockSetResultExpectation

	callArgs []*RecordStoreMockSetResultParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetResultExpectation specifies expectation struct of the RecordStore.SetResult
type RecordStoreMockSetResultExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetResultParams
	results *RecordStoreMockSetResultResults
	Counter uint64
}

// RecordStoreMockSetResultParams contains parameters of the RecordStore.SetResult
type RecordStoreMockSetResultParams struct {
	ctx    context.Context
	record record.Material
}

// RecordStoreMockSetResultResults contains results of the RecordStore.SetResult
type RecordStoreMockSetResultResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetResult
func (mmSetResult *mRecordStoreMockSetResult) Expect(ctx context.Context, record record.Material) *mRecordStoreMockSetResult {
	if mmSetResult.mock.funcSetResult != nil {
		mmSetResult.mock.t.Fatalf("RecordStoreMock.SetResult mock is already set by Set")
	}

	if mmSetResult.defaultExpectation == nil {
		mmSetResult.defaultExpectation = &RecordStoreMockSetResultExpectation{}
	}

	mmSetResult.defaultExpectation.params = &RecordStoreMockSetResultParams{ctx, record}
	for _, e := range mmSetResult.expectations {
		if minimock.Equal(e.params, mmSetResult.defaultExpectation.params) {
			mmSetResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetResult.defaultExpectation.params)
		}
	}

	return mmSetResult
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetResult
func (mmSetResult *mRecordStoreMockSetResult) Inspect(f func(ctx context.Context, record record.Material)) *mRecordStoreMockSetResult {
	if mmSetResult.mock.inspectFuncSetResult != nil {
		mmSetResult.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetResult")
	}

	mmSetResult.mock.inspectFuncSetResult = f

	return mmSetResult
}

// Return sets up results that will be returned by RecordStore.SetResult
func (mmSetResult *mRecordStoreMockSetResult) Return(err error) *RecordStoreMock {
	if mmSetResult.mock.funcSetResult != nil {
		mmSetResult.mock.t.Fatalf("RecordStoreMock.SetResult mock is already set by Set")
	}

	if mmSetResult.defaultExpectation == nil {
		mmSetResult.defaultExpectation = &RecordStoreMockSetResultExpectation{mock: mmSetResult.mock}
	}
	mmSetResult.defaultExpectation.results = &RecordStoreMockSetResultResults{err}
	return mmSetResult.mock
}

//Set uses given function f to mock the RecordStore.SetResult method
func (mmSetResult *mRecordStoreMockSetResult) Set(f func(ctx context.Context, record record.Material) (err error)) *RecordStoreMock {
	if mmSetResult.defaultExpectation != nil {
		mmSetResult.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetResult method")
	}

	if len(mmSetResult.expectations) > 0 {
		mmSetResult.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetResult method")
	}

	mmSetResult.mock.funcSetResult = f
	return mmSetResult.mock
}

// When sets expectation for the RecordStore.SetResult which will trigger the result defined by the following
// Then helper
func (mmSetResult *mRecordStoreMockSetResult) When(ctx context.Context, record record.Material) *RecordStoreMockSetResultExpectation {
	if mmSetResult.mock.funcSetResult != nil {
		mmSetResult.mock.t.Fatalf("RecordStoreMock.SetResult mock is already set by Set")
	}

	expectation := &RecordStoreMockSetResultExpectation{
		mock:   mmSetResult.mock,
		params: &RecordStoreMockSetResultParams{ctx, record},
	}
	mmSetResult.expectations = append(mmSetResult.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetResult return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetResultExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetResultResults{err}
	return e.mock
}

// SetResult implements RecordStore
func (mmSetResult *RecordStoreMock) SetResult(ctx context.Context, record record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetResult.beforeSetResultCounter, 1)
	defer mm_atomic.AddUint64(&mmSetResult.afterSetResultCounter, 1)

	if mmSetResult.inspectFuncSetResult != nil {
		mmSetResult.inspectFuncSetResult(ctx, record)
	}

	params := &RecordStoreMockSetResultParams{ctx, record}

	// Record call args
	mmSetResult.SetResultMock.mutex.Lock()
	mmSetResult.SetResultMock.callArgs = append(mmSetResult.SetResultMock.callArgs, params)
	mmSetResult.SetResultMock.mutex.Unlock()

	for _, e := range mmSetResult.SetResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetResult.SetResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetResult.SetResultMock.defaultExpectation.Counter, 1)
		want := mmSetResult.SetResultMock.defaultExpectation.params
		got := RecordStoreMockSetResultParams{ctx, record}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetResult.t.Errorf("RecordStoreMock.SetResult got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSetResult.SetResultMock.defaultExpectation.results
		if results == nil {
			mmSetResult.t.Fatal("No results are set for the RecordStoreMock.SetResult")
		}
		return (*results).err
	}
	if mmSetResult.funcSetResult != nil {
		return mmSetResult.funcSetResult(ctx, record)
	}
	mmSetResult.t.Fatalf("Unexpected call to RecordStoreMock.SetResult. %v %v", ctx, record)
	return
}

// SetResultAfterCounter returns a count of finished RecordStoreMock.SetResult invocations
func (mmSetResult *RecordStoreMock) SetResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetResult.afterSetResultCounter)
}

// SetResultBeforeCounter returns a count of RecordStoreMock.SetResult invocations
func (mmSetResult *RecordStoreMock) SetResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetResult.beforeSetResultCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetResult *mRecordStoreMockSetResult) Calls() []*RecordStoreMockSetResultParams {
	mmSetResult.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetResultParams, len(mmSetResult.callArgs))
	copy(argCopy, mmSetResult.callArgs)

	mmSetResult.mutex.RUnlock()

	return argCopy
}

// MinimockSetResultDone returns true if the count of the SetResult invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetResultDone() bool {
	for _, e := range m.SetResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetResult != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetResultInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetResultInspect() {
	for _, e := range m.SetResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		if m.SetResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetResult")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetResult with params: %#v", *m.SetResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetResult != nil && mm_atomic.LoadUint64(&m.afterSetResultCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetResult")
	}
}

type mRecordStoreMockSetSideEffect struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSetSideEffectExpectation
	expectations       []*RecordStoreMockSetSideEffectExpectation

	callArgs []*RecordStoreMockSetSideEffectParams
	mutex    sync.RWMutex
}

// RecordStoreMockSetSideEffectExpectation specifies expectation struct of the RecordStore.SetSideEffect
type RecordStoreMockSetSideEffectExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSetSideEffectParams
	results *RecordStoreMockSetSideEffectResults
	Counter uint64
}

// RecordStoreMockSetSideEffectParams contains parameters of the RecordStore.SetSideEffect
type RecordStoreMockSetSideEffectParams struct {
	ctx    context.Context
	record record.Material
}

// RecordStoreMockSetSideEffectResults contains results of the RecordStore.SetSideEffect
type RecordStoreMockSetSideEffectResults struct {
	err error
}

// Expect sets up expected params for RecordStore.SetSideEffect
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Expect(ctx context.Context, record record.Material) *mRecordStoreMockSetSideEffect {
	if mmSetSideEffect.mock.funcSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("RecordStoreMock.SetSideEffect mock is already set by Set")
	}

	if mmSetSideEffect.defaultExpectation == nil {
		mmSetSideEffect.defaultExpectation = &RecordStoreMockSetSideEffectExpectation{}
	}

	mmSetSideEffect.defaultExpectation.params = &RecordStoreMockSetSideEffectParams{ctx, record}
	for _, e := range mmSetSideEffect.expectations {
		if minimock.Equal(e.params, mmSetSideEffect.defaultExpectation.params) {
			mmSetSideEffect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetSideEffect.defaultExpectation.params)
		}
	}

	return mmSetSideEffect
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SetSideEffect
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Inspect(f func(ctx context.Context, record record.Material)) *mRecordStoreMockSetSideEffect {
	if mmSetSideEffect.mock.inspectFuncSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SetSideEffect")
	}

	mmSetSideEffect.mock.inspectFuncSetSideEffect = f

	return mmSetSideEffect
}

// Return sets up results that will be returned by RecordStore.SetSideEffect
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Return(err error) *RecordStoreMock {
	if mmSetSideEffect.mock.funcSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("RecordStoreMock.SetSideEffect mock is already set by Set")
	}

	if mmSetSideEffect.defaultExpectation == nil {
		mmSetSideEffect.defaultExpectation = &RecordStoreMockSetSideEffectExpectation{mock: mmSetSideEffect.mock}
	}
	mmSetSideEffect.defaultExpectation.results = &RecordStoreMockSetSideEffectResults{err}
	return mmSetSideEffect.mock
}

//Set uses given function f to mock the RecordStore.SetSideEffect method
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Set(f func(ctx context.Context, record record.Material) (err error)) *RecordStoreMock {
	if mmSetSideEffect.defaultExpectation != nil {
		mmSetSideEffect.mock.t.Fatalf("Default expectation is already set for the RecordStore.SetSideEffect method")
	}

	if len(mmSetSideEffect.expectations) > 0 {
		mmSetSideEffect.mock.t.Fatalf("Some expectations are already set for the RecordStore.SetSideEffect method")
	}

	mmSetSideEffect.mock.funcSetSideEffect = f
	return mmSetSideEffect.mock
}

// When sets expectation for the RecordStore.SetSideEffect which will trigger the result defined by the following
// Then helper
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) When(ctx context.Context, record record.Material) *RecordStoreMockSetSideEffectExpectation {
	if mmSetSideEffect.mock.funcSetSideEffect != nil {
		mmSetSideEffect.mock.t.Fatalf("RecordStoreMock.SetSideEffect mock is already set by Set")
	}

	expectation := &RecordStoreMockSetSideEffectExpectation{
		mock:   mmSetSideEffect.mock,
		params: &RecordStoreMockSetSideEffectParams{ctx, record},
	}
	mmSetSideEffect.expectations = append(mmSetSideEffect.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SetSideEffect return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSetSideEffectExpectation) Then(err error) *RecordStoreMock {
	e.results = &RecordStoreMockSetSideEffectResults{err}
	return e.mock
}

// SetSideEffect implements RecordStore
func (mmSetSideEffect *RecordStoreMock) SetSideEffect(ctx context.Context, record record.Material) (err error) {
	mm_atomic.AddUint64(&mmSetSideEffect.beforeSetSideEffectCounter, 1)
	defer mm_atomic.AddUint64(&mmSetSideEffect.afterSetSideEffectCounter, 1)

	if mmSetSideEffect.inspectFuncSetSideEffect != nil {
		mmSetSideEffect.inspectFuncSetSideEffect(ctx, record)
	}

	params := &RecordStoreMockSetSideEffectParams{ctx, record}

	// Record call args
	mmSetSideEffect.SetSideEffectMock.mutex.Lock()
	mmSetSideEffect.SetSideEffectMock.callArgs = append(mmSetSideEffect.SetSideEffectMock.callArgs, params)
	mmSetSideEffect.SetSideEffectMock.mutex.Unlock()

	for _, e := range mmSetSideEffect.SetSideEffectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetSideEffect.SetSideEffectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetSideEffect.SetSideEffectMock.defaultExpectation.Counter, 1)
		want := mmSetSideEffect.SetSideEffectMock.defaultExpectation.params
		got := RecordStoreMockSetSideEffectParams{ctx, record}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetSideEffect.t.Errorf("RecordStoreMock.SetSideEffect got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSetSideEffect.SetSideEffectMock.defaultExpectation.results
		if results == nil {
			mmSetSideEffect.t.Fatal("No results are set for the RecordStoreMock.SetSideEffect")
		}
		return (*results).err
	}
	if mmSetSideEffect.funcSetSideEffect != nil {
		return mmSetSideEffect.funcSetSideEffect(ctx, record)
	}
	mmSetSideEffect.t.Fatalf("Unexpected call to RecordStoreMock.SetSideEffect. %v %v", ctx, record)
	return
}

// SetSideEffectAfterCounter returns a count of finished RecordStoreMock.SetSideEffect invocations
func (mmSetSideEffect *RecordStoreMock) SetSideEffectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSideEffect.afterSetSideEffectCounter)
}

// SetSideEffectBeforeCounter returns a count of RecordStoreMock.SetSideEffect invocations
func (mmSetSideEffect *RecordStoreMock) SetSideEffectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetSideEffect.beforeSetSideEffectCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SetSideEffect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetSideEffect *mRecordStoreMockSetSideEffect) Calls() []*RecordStoreMockSetSideEffectParams {
	mmSetSideEffect.mutex.RLock()

	argCopy := make([]*RecordStoreMockSetSideEffectParams, len(mmSetSideEffect.callArgs))
	copy(argCopy, mmSetSideEffect.callArgs)

	mmSetSideEffect.mutex.RUnlock()

	return argCopy
}

// MinimockSetSideEffectDone returns true if the count of the SetSideEffect invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSetSideEffectDone() bool {
	for _, e := range m.SetSideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSideEffect != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetSideEffectInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSetSideEffectInspect() {
	for _, e := range m.SetSideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SetSideEffect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetSideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		if m.SetSideEffectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SetSideEffect")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SetSideEffect with params: %#v", *m.SetSideEffectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetSideEffect != nil && mm_atomic.LoadUint64(&m.afterSetSideEffectCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SetSideEffect")
	}
}

type mRecordStoreMockSideEffect struct {
	mock               *RecordStoreMock
	defaultExpectation *RecordStoreMockSideEffectExpectation
	expectations       []*RecordStoreMockSideEffectExpectation

	callArgs []*RecordStoreMockSideEffectParams
	mutex    sync.RWMutex
}

// RecordStoreMockSideEffectExpectation specifies expectation struct of the RecordStore.SideEffect
type RecordStoreMockSideEffectExpectation struct {
	mock    *RecordStoreMock
	params  *RecordStoreMockSideEffectParams
	results *RecordStoreMockSideEffectResults
	Counter uint64
}

// RecordStoreMockSideEffectParams contains parameters of the RecordStore.SideEffect
type RecordStoreMockSideEffectParams struct {
	ctx   context.Context
	reqID insolar.ID
}

// RecordStoreMockSideEffectResults contains results of the RecordStore.SideEffect
type RecordStoreMockSideEffectResults struct {
	m1  record.Material
	err error
}

// Expect sets up expected params for RecordStore.SideEffect
func (mmSideEffect *mRecordStoreMockSideEffect) Expect(ctx context.Context, reqID insolar.ID) *mRecordStoreMockSideEffect {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordStoreMock.SideEffect mock is already set by Set")
	}

	if mmSideEffect.defaultExpectation == nil {
		mmSideEffect.defaultExpectation = &RecordStoreMockSideEffectExpectation{}
	}

	mmSideEffect.defaultExpectation.params = &RecordStoreMockSideEffectParams{ctx, reqID}
	for _, e := range mmSideEffect.expectations {
		if minimock.Equal(e.params, mmSideEffect.defaultExpectation.params) {
			mmSideEffect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSideEffect.defaultExpectation.params)
		}
	}

	return mmSideEffect
}

// Inspect accepts an inspector function that has same arguments as the RecordStore.SideEffect
func (mmSideEffect *mRecordStoreMockSideEffect) Inspect(f func(ctx context.Context, reqID insolar.ID)) *mRecordStoreMockSideEffect {
	if mmSideEffect.mock.inspectFuncSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("Inspect function is already set for RecordStoreMock.SideEffect")
	}

	mmSideEffect.mock.inspectFuncSideEffect = f

	return mmSideEffect
}

// Return sets up results that will be returned by RecordStore.SideEffect
func (mmSideEffect *mRecordStoreMockSideEffect) Return(m1 record.Material, err error) *RecordStoreMock {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordStoreMock.SideEffect mock is already set by Set")
	}

	if mmSideEffect.defaultExpectation == nil {
		mmSideEffect.defaultExpectation = &RecordStoreMockSideEffectExpectation{mock: mmSideEffect.mock}
	}
	mmSideEffect.defaultExpectation.results = &RecordStoreMockSideEffectResults{m1, err}
	return mmSideEffect.mock
}

//Set uses given function f to mock the RecordStore.SideEffect method
func (mmSideEffect *mRecordStoreMockSideEffect) Set(f func(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error)) *RecordStoreMock {
	if mmSideEffect.defaultExpectation != nil {
		mmSideEffect.mock.t.Fatalf("Default expectation is already set for the RecordStore.SideEffect method")
	}

	if len(mmSideEffect.expectations) > 0 {
		mmSideEffect.mock.t.Fatalf("Some expectations are already set for the RecordStore.SideEffect method")
	}

	mmSideEffect.mock.funcSideEffect = f
	return mmSideEffect.mock
}

// When sets expectation for the RecordStore.SideEffect which will trigger the result defined by the following
// Then helper
func (mmSideEffect *mRecordStoreMockSideEffect) When(ctx context.Context, reqID insolar.ID) *RecordStoreMockSideEffectExpectation {
	if mmSideEffect.mock.funcSideEffect != nil {
		mmSideEffect.mock.t.Fatalf("RecordStoreMock.SideEffect mock is already set by Set")
	}

	expectation := &RecordStoreMockSideEffectExpectation{
		mock:   mmSideEffect.mock,
		params: &RecordStoreMockSideEffectParams{ctx, reqID},
	}
	mmSideEffect.expectations = append(mmSideEffect.expectations, expectation)
	return expectation
}

// Then sets up RecordStore.SideEffect return parameters for the expectation previously defined by the When method
func (e *RecordStoreMockSideEffectExpectation) Then(m1 record.Material, err error) *RecordStoreMock {
	e.results = &RecordStoreMockSideEffectResults{m1, err}
	return e.mock
}

// SideEffect implements RecordStore
func (mmSideEffect *RecordStoreMock) SideEffect(ctx context.Context, reqID insolar.ID) (m1 record.Material, err error) {
	mm_atomic.AddUint64(&mmSideEffect.beforeSideEffectCounter, 1)
	defer mm_atomic.AddUint64(&mmSideEffect.afterSideEffectCounter, 1)

	if mmSideEffect.inspectFuncSideEffect != nil {
		mmSideEffect.inspectFuncSideEffect(ctx, reqID)
	}

	params := &RecordStoreMockSideEffectParams{ctx, reqID}

	// Record call args
	mmSideEffect.SideEffectMock.mutex.Lock()
	mmSideEffect.SideEffectMock.callArgs = append(mmSideEffect.SideEffectMock.callArgs, params)
	mmSideEffect.SideEffectMock.mutex.Unlock()

	for _, e := range mmSideEffect.SideEffectMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmSideEffect.SideEffectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSideEffect.SideEffectMock.defaultExpectation.Counter, 1)
		want := mmSideEffect.SideEffectMock.defaultExpectation.params
		got := RecordStoreMockSideEffectParams{ctx, reqID}
		if want != nil && !minimock.Equal(*want, got) {
			mmSideEffect.t.Errorf("RecordStoreMock.SideEffect got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSideEffect.SideEffectMock.defaultExpectation.results
		if results == nil {
			mmSideEffect.t.Fatal("No results are set for the RecordStoreMock.SideEffect")
		}
		return (*results).m1, (*results).err
	}
	if mmSideEffect.funcSideEffect != nil {
		return mmSideEffect.funcSideEffect(ctx, reqID)
	}
	mmSideEffect.t.Fatalf("Unexpected call to RecordStoreMock.SideEffect. %v %v", ctx, reqID)
	return
}

// SideEffectAfterCounter returns a count of finished RecordStoreMock.SideEffect invocations
func (mmSideEffect *RecordStoreMock) SideEffectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSideEffect.afterSideEffectCounter)
}

// SideEffectBeforeCounter returns a count of RecordStoreMock.SideEffect invocations
func (mmSideEffect *RecordStoreMock) SideEffectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSideEffect.beforeSideEffectCounter)
}

// Calls returns a list of arguments used in each call to RecordStoreMock.SideEffect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSideEffect *mRecordStoreMockSideEffect) Calls() []*RecordStoreMockSideEffectParams {
	mmSideEffect.mutex.RLock()

	argCopy := make([]*RecordStoreMockSideEffectParams, len(mmSideEffect.callArgs))
	copy(argCopy, mmSideEffect.callArgs)

	mmSideEffect.mutex.RUnlock()

	return argCopy
}

// MinimockSideEffectDone returns true if the count of the SideEffect invocations corresponds
// the number of defined expectations
func (m *RecordStoreMock) MinimockSideEffectDone() bool {
	for _, e := range m.SideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSideEffect != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSideEffectInspect logs each unmet expectation
func (m *RecordStoreMock) MinimockSideEffectInspect() {
	for _, e := range m.SideEffectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RecordStoreMock.SideEffect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SideEffectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		if m.SideEffectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RecordStoreMock.SideEffect")
		} else {
			m.t.Errorf("Expected call to RecordStoreMock.SideEffect with params: %#v", *m.SideEffectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSideEffect != nil && mm_atomic.LoadUint64(&m.afterSideEffectCounter) < 1 {
		m.t.Error("Expected call to RecordStoreMock.SideEffect")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RecordStoreMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCalledRequestsInspect()

		m.MinimockRequestInspect()

		m.MinimockResultInspect()

		m.MinimockSetRequestInspect()

		m.MinimockSetResultInspect()

		m.MinimockSetSideEffectInspect()

		m.MinimockSideEffectInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RecordStoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RecordStoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCalledRequestsDone() &&
		m.MinimockRequestDone() &&
		m.MinimockResultDone() &&
		m.MinimockSetRequestDone() &&
		m.MinimockSetResultDone() &&
		m.MinimockSetSideEffectDone() &&
		m.MinimockSideEffectDone()
}
