package postgres

// Code generated by http://github.com/gojuno/minimock (2.1.9). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// SupplyStatsRepoMock implements SupplyStatsRepo
type SupplyStatsRepoMock struct {
	t minimock.Tester

	funcCountStats          func(time *time.Time) (s1 SupplyStatsModel, err error)
	inspectFuncCountStats   func(time *time.Time)
	afterCountStatsCounter  uint64
	beforeCountStatsCounter uint64
	CountStatsMock          mSupplyStatsRepoMockCountStats

	funcInsertStats          func(s1 SupplyStatsModel) (err error)
	inspectFuncInsertStats   func(s1 SupplyStatsModel)
	afterInsertStatsCounter  uint64
	beforeInsertStatsCounter uint64
	InsertStatsMock          mSupplyStatsRepoMockInsertStats

	funcLastStats          func() (s1 SupplyStatsModel, err error)
	inspectFuncLastStats   func()
	afterLastStatsCounter  uint64
	beforeLastStatsCounter uint64
	LastStatsMock          mSupplyStatsRepoMockLastStats
}

// NewSupplyStatsRepoMock returns a mock for SupplyStatsRepo
func NewSupplyStatsRepoMock(t minimock.Tester) *SupplyStatsRepoMock {
	m := &SupplyStatsRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CountStatsMock = mSupplyStatsRepoMockCountStats{mock: m}
	m.CountStatsMock.callArgs = []*SupplyStatsRepoMockCountStatsParams{}

	m.InsertStatsMock = mSupplyStatsRepoMockInsertStats{mock: m}
	m.InsertStatsMock.callArgs = []*SupplyStatsRepoMockInsertStatsParams{}

	m.LastStatsMock = mSupplyStatsRepoMockLastStats{mock: m}

	return m
}

type mSupplyStatsRepoMockCountStats struct {
	mock               *SupplyStatsRepoMock
	defaultExpectation *SupplyStatsRepoMockCountStatsExpectation
	expectations       []*SupplyStatsRepoMockCountStatsExpectation

	callArgs []*SupplyStatsRepoMockCountStatsParams
	mutex    sync.RWMutex
}

// SupplyStatsRepoMockCountStatsExpectation specifies expectation struct of the SupplyStatsRepo.CountStats
type SupplyStatsRepoMockCountStatsExpectation struct {
	mock    *SupplyStatsRepoMock
	params  *SupplyStatsRepoMockCountStatsParams
	results *SupplyStatsRepoMockCountStatsResults
	Counter uint64
}

// SupplyStatsRepoMockCountStatsParams contains parameters of the SupplyStatsRepo.CountStats
type SupplyStatsRepoMockCountStatsParams struct {
	time *time.Time
}

// SupplyStatsRepoMockCountStatsResults contains results of the SupplyStatsRepo.CountStats
type SupplyStatsRepoMockCountStatsResults struct {
	s1  SupplyStatsModel
	err error
}

// Expect sets up expected params for SupplyStatsRepo.CountStats
func (mmCountStats *mSupplyStatsRepoMockCountStats) Expect(time *time.Time) *mSupplyStatsRepoMockCountStats {
	if mmCountStats.mock.funcCountStats != nil {
		mmCountStats.mock.t.Fatalf("SupplyStatsRepoMock.CountStats mock is already set by Set")
	}

	if mmCountStats.defaultExpectation == nil {
		mmCountStats.defaultExpectation = &SupplyStatsRepoMockCountStatsExpectation{}
	}

	mmCountStats.defaultExpectation.params = &SupplyStatsRepoMockCountStatsParams{time}
	for _, e := range mmCountStats.expectations {
		if minimock.Equal(e.params, mmCountStats.defaultExpectation.params) {
			mmCountStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCountStats.defaultExpectation.params)
		}
	}

	return mmCountStats
}

// Inspect accepts an inspector function that has same arguments as the SupplyStatsRepo.CountStats
func (mmCountStats *mSupplyStatsRepoMockCountStats) Inspect(f func(time *time.Time)) *mSupplyStatsRepoMockCountStats {
	if mmCountStats.mock.inspectFuncCountStats != nil {
		mmCountStats.mock.t.Fatalf("Inspect function is already set for SupplyStatsRepoMock.CountStats")
	}

	mmCountStats.mock.inspectFuncCountStats = f

	return mmCountStats
}

// Return sets up results that will be returned by SupplyStatsRepo.CountStats
func (mmCountStats *mSupplyStatsRepoMockCountStats) Return(s1 SupplyStatsModel, err error) *SupplyStatsRepoMock {
	if mmCountStats.mock.funcCountStats != nil {
		mmCountStats.mock.t.Fatalf("SupplyStatsRepoMock.CountStats mock is already set by Set")
	}

	if mmCountStats.defaultExpectation == nil {
		mmCountStats.defaultExpectation = &SupplyStatsRepoMockCountStatsExpectation{mock: mmCountStats.mock}
	}
	mmCountStats.defaultExpectation.results = &SupplyStatsRepoMockCountStatsResults{s1, err}
	return mmCountStats.mock
}

//Set uses given function f to mock the SupplyStatsRepo.CountStats method
func (mmCountStats *mSupplyStatsRepoMockCountStats) Set(f func(time *time.Time) (s1 SupplyStatsModel, err error)) *SupplyStatsRepoMock {
	if mmCountStats.defaultExpectation != nil {
		mmCountStats.mock.t.Fatalf("Default expectation is already set for the SupplyStatsRepo.CountStats method")
	}

	if len(mmCountStats.expectations) > 0 {
		mmCountStats.mock.t.Fatalf("Some expectations are already set for the SupplyStatsRepo.CountStats method")
	}

	mmCountStats.mock.funcCountStats = f
	return mmCountStats.mock
}

// When sets expectation for the SupplyStatsRepo.CountStats which will trigger the result defined by the following
// Then helper
func (mmCountStats *mSupplyStatsRepoMockCountStats) When(time *time.Time) *SupplyStatsRepoMockCountStatsExpectation {
	if mmCountStats.mock.funcCountStats != nil {
		mmCountStats.mock.t.Fatalf("SupplyStatsRepoMock.CountStats mock is already set by Set")
	}

	expectation := &SupplyStatsRepoMockCountStatsExpectation{
		mock:   mmCountStats.mock,
		params: &SupplyStatsRepoMockCountStatsParams{time},
	}
	mmCountStats.expectations = append(mmCountStats.expectations, expectation)
	return expectation
}

// Then sets up SupplyStatsRepo.CountStats return parameters for the expectation previously defined by the When method
func (e *SupplyStatsRepoMockCountStatsExpectation) Then(s1 SupplyStatsModel, err error) *SupplyStatsRepoMock {
	e.results = &SupplyStatsRepoMockCountStatsResults{s1, err}
	return e.mock
}

// CountStats implements SupplyStatsRepo
func (mmCountStats *SupplyStatsRepoMock) CountStats(time *time.Time) (s1 SupplyStatsModel, err error) {
	mm_atomic.AddUint64(&mmCountStats.beforeCountStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmCountStats.afterCountStatsCounter, 1)

	if mmCountStats.inspectFuncCountStats != nil {
		mmCountStats.inspectFuncCountStats(time)
	}

	mm_params := &SupplyStatsRepoMockCountStatsParams{time}

	// Record call args
	mmCountStats.CountStatsMock.mutex.Lock()
	mmCountStats.CountStatsMock.callArgs = append(mmCountStats.CountStatsMock.callArgs, mm_params)
	mmCountStats.CountStatsMock.mutex.Unlock()

	for _, e := range mmCountStats.CountStatsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCountStats.CountStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCountStats.CountStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmCountStats.CountStatsMock.defaultExpectation.params
		mm_got := SupplyStatsRepoMockCountStatsParams{time}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCountStats.t.Errorf("SupplyStatsRepoMock.CountStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCountStats.CountStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmCountStats.t.Fatal("No results are set for the SupplyStatsRepoMock.CountStats")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCountStats.funcCountStats != nil {
		return mmCountStats.funcCountStats(time)
	}
	mmCountStats.t.Fatalf("Unexpected call to SupplyStatsRepoMock.CountStats. %v", time)
	return
}

// CountStatsAfterCounter returns a count of finished SupplyStatsRepoMock.CountStats invocations
func (mmCountStats *SupplyStatsRepoMock) CountStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountStats.afterCountStatsCounter)
}

// CountStatsBeforeCounter returns a count of SupplyStatsRepoMock.CountStats invocations
func (mmCountStats *SupplyStatsRepoMock) CountStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountStats.beforeCountStatsCounter)
}

// Calls returns a list of arguments used in each call to SupplyStatsRepoMock.CountStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCountStats *mSupplyStatsRepoMockCountStats) Calls() []*SupplyStatsRepoMockCountStatsParams {
	mmCountStats.mutex.RLock()

	argCopy := make([]*SupplyStatsRepoMockCountStatsParams, len(mmCountStats.callArgs))
	copy(argCopy, mmCountStats.callArgs)

	mmCountStats.mutex.RUnlock()

	return argCopy
}

// MinimockCountStatsDone returns true if the count of the CountStats invocations corresponds
// the number of defined expectations
func (m *SupplyStatsRepoMock) MinimockCountStatsDone() bool {
	for _, e := range m.CountStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CountStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountStats != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCountStatsInspect logs each unmet expectation
func (m *SupplyStatsRepoMock) MinimockCountStatsInspect() {
	for _, e := range m.CountStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SupplyStatsRepoMock.CountStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CountStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		if m.CountStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SupplyStatsRepoMock.CountStats")
		} else {
			m.t.Errorf("Expected call to SupplyStatsRepoMock.CountStats with params: %#v", *m.CountStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountStats != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		m.t.Error("Expected call to SupplyStatsRepoMock.CountStats")
	}
}

type mSupplyStatsRepoMockInsertStats struct {
	mock               *SupplyStatsRepoMock
	defaultExpectation *SupplyStatsRepoMockInsertStatsExpectation
	expectations       []*SupplyStatsRepoMockInsertStatsExpectation

	callArgs []*SupplyStatsRepoMockInsertStatsParams
	mutex    sync.RWMutex
}

// SupplyStatsRepoMockInsertStatsExpectation specifies expectation struct of the SupplyStatsRepo.InsertStats
type SupplyStatsRepoMockInsertStatsExpectation struct {
	mock    *SupplyStatsRepoMock
	params  *SupplyStatsRepoMockInsertStatsParams
	results *SupplyStatsRepoMockInsertStatsResults
	Counter uint64
}

// SupplyStatsRepoMockInsertStatsParams contains parameters of the SupplyStatsRepo.InsertStats
type SupplyStatsRepoMockInsertStatsParams struct {
	s1 SupplyStatsModel
}

// SupplyStatsRepoMockInsertStatsResults contains results of the SupplyStatsRepo.InsertStats
type SupplyStatsRepoMockInsertStatsResults struct {
	err error
}

// Expect sets up expected params for SupplyStatsRepo.InsertStats
func (mmInsertStats *mSupplyStatsRepoMockInsertStats) Expect(s1 SupplyStatsModel) *mSupplyStatsRepoMockInsertStats {
	if mmInsertStats.mock.funcInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("SupplyStatsRepoMock.InsertStats mock is already set by Set")
	}

	if mmInsertStats.defaultExpectation == nil {
		mmInsertStats.defaultExpectation = &SupplyStatsRepoMockInsertStatsExpectation{}
	}

	mmInsertStats.defaultExpectation.params = &SupplyStatsRepoMockInsertStatsParams{s1}
	for _, e := range mmInsertStats.expectations {
		if minimock.Equal(e.params, mmInsertStats.defaultExpectation.params) {
			mmInsertStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertStats.defaultExpectation.params)
		}
	}

	return mmInsertStats
}

// Inspect accepts an inspector function that has same arguments as the SupplyStatsRepo.InsertStats
func (mmInsertStats *mSupplyStatsRepoMockInsertStats) Inspect(f func(s1 SupplyStatsModel)) *mSupplyStatsRepoMockInsertStats {
	if mmInsertStats.mock.inspectFuncInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("Inspect function is already set for SupplyStatsRepoMock.InsertStats")
	}

	mmInsertStats.mock.inspectFuncInsertStats = f

	return mmInsertStats
}

// Return sets up results that will be returned by SupplyStatsRepo.InsertStats
func (mmInsertStats *mSupplyStatsRepoMockInsertStats) Return(err error) *SupplyStatsRepoMock {
	if mmInsertStats.mock.funcInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("SupplyStatsRepoMock.InsertStats mock is already set by Set")
	}

	if mmInsertStats.defaultExpectation == nil {
		mmInsertStats.defaultExpectation = &SupplyStatsRepoMockInsertStatsExpectation{mock: mmInsertStats.mock}
	}
	mmInsertStats.defaultExpectation.results = &SupplyStatsRepoMockInsertStatsResults{err}
	return mmInsertStats.mock
}

//Set uses given function f to mock the SupplyStatsRepo.InsertStats method
func (mmInsertStats *mSupplyStatsRepoMockInsertStats) Set(f func(s1 SupplyStatsModel) (err error)) *SupplyStatsRepoMock {
	if mmInsertStats.defaultExpectation != nil {
		mmInsertStats.mock.t.Fatalf("Default expectation is already set for the SupplyStatsRepo.InsertStats method")
	}

	if len(mmInsertStats.expectations) > 0 {
		mmInsertStats.mock.t.Fatalf("Some expectations are already set for the SupplyStatsRepo.InsertStats method")
	}

	mmInsertStats.mock.funcInsertStats = f
	return mmInsertStats.mock
}

// When sets expectation for the SupplyStatsRepo.InsertStats which will trigger the result defined by the following
// Then helper
func (mmInsertStats *mSupplyStatsRepoMockInsertStats) When(s1 SupplyStatsModel) *SupplyStatsRepoMockInsertStatsExpectation {
	if mmInsertStats.mock.funcInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("SupplyStatsRepoMock.InsertStats mock is already set by Set")
	}

	expectation := &SupplyStatsRepoMockInsertStatsExpectation{
		mock:   mmInsertStats.mock,
		params: &SupplyStatsRepoMockInsertStatsParams{s1},
	}
	mmInsertStats.expectations = append(mmInsertStats.expectations, expectation)
	return expectation
}

// Then sets up SupplyStatsRepo.InsertStats return parameters for the expectation previously defined by the When method
func (e *SupplyStatsRepoMockInsertStatsExpectation) Then(err error) *SupplyStatsRepoMock {
	e.results = &SupplyStatsRepoMockInsertStatsResults{err}
	return e.mock
}

// InsertStats implements SupplyStatsRepo
func (mmInsertStats *SupplyStatsRepoMock) InsertStats(s1 SupplyStatsModel) (err error) {
	mm_atomic.AddUint64(&mmInsertStats.beforeInsertStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertStats.afterInsertStatsCounter, 1)

	if mmInsertStats.inspectFuncInsertStats != nil {
		mmInsertStats.inspectFuncInsertStats(s1)
	}

	mm_params := &SupplyStatsRepoMockInsertStatsParams{s1}

	// Record call args
	mmInsertStats.InsertStatsMock.mutex.Lock()
	mmInsertStats.InsertStatsMock.callArgs = append(mmInsertStats.InsertStatsMock.callArgs, mm_params)
	mmInsertStats.InsertStatsMock.mutex.Unlock()

	for _, e := range mmInsertStats.InsertStatsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertStats.InsertStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertStats.InsertStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertStats.InsertStatsMock.defaultExpectation.params
		mm_got := SupplyStatsRepoMockInsertStatsParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertStats.t.Errorf("SupplyStatsRepoMock.InsertStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertStats.InsertStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertStats.t.Fatal("No results are set for the SupplyStatsRepoMock.InsertStats")
		}
		return (*mm_results).err
	}
	if mmInsertStats.funcInsertStats != nil {
		return mmInsertStats.funcInsertStats(s1)
	}
	mmInsertStats.t.Fatalf("Unexpected call to SupplyStatsRepoMock.InsertStats. %v", s1)
	return
}

// InsertStatsAfterCounter returns a count of finished SupplyStatsRepoMock.InsertStats invocations
func (mmInsertStats *SupplyStatsRepoMock) InsertStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertStats.afterInsertStatsCounter)
}

// InsertStatsBeforeCounter returns a count of SupplyStatsRepoMock.InsertStats invocations
func (mmInsertStats *SupplyStatsRepoMock) InsertStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertStats.beforeInsertStatsCounter)
}

// Calls returns a list of arguments used in each call to SupplyStatsRepoMock.InsertStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertStats *mSupplyStatsRepoMockInsertStats) Calls() []*SupplyStatsRepoMockInsertStatsParams {
	mmInsertStats.mutex.RLock()

	argCopy := make([]*SupplyStatsRepoMockInsertStatsParams, len(mmInsertStats.callArgs))
	copy(argCopy, mmInsertStats.callArgs)

	mmInsertStats.mutex.RUnlock()

	return argCopy
}

// MinimockInsertStatsDone returns true if the count of the InsertStats invocations corresponds
// the number of defined expectations
func (m *SupplyStatsRepoMock) MinimockInsertStatsDone() bool {
	for _, e := range m.InsertStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertStats != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertStatsInspect logs each unmet expectation
func (m *SupplyStatsRepoMock) MinimockInsertStatsInspect() {
	for _, e := range m.InsertStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SupplyStatsRepoMock.InsertStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		if m.InsertStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SupplyStatsRepoMock.InsertStats")
		} else {
			m.t.Errorf("Expected call to SupplyStatsRepoMock.InsertStats with params: %#v", *m.InsertStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertStats != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		m.t.Error("Expected call to SupplyStatsRepoMock.InsertStats")
	}
}

type mSupplyStatsRepoMockLastStats struct {
	mock               *SupplyStatsRepoMock
	defaultExpectation *SupplyStatsRepoMockLastStatsExpectation
	expectations       []*SupplyStatsRepoMockLastStatsExpectation
}

// SupplyStatsRepoMockLastStatsExpectation specifies expectation struct of the SupplyStatsRepo.LastStats
type SupplyStatsRepoMockLastStatsExpectation struct {
	mock *SupplyStatsRepoMock

	results *SupplyStatsRepoMockLastStatsResults
	Counter uint64
}

// SupplyStatsRepoMockLastStatsResults contains results of the SupplyStatsRepo.LastStats
type SupplyStatsRepoMockLastStatsResults struct {
	s1  SupplyStatsModel
	err error
}

// Expect sets up expected params for SupplyStatsRepo.LastStats
func (mmLastStats *mSupplyStatsRepoMockLastStats) Expect() *mSupplyStatsRepoMockLastStats {
	if mmLastStats.mock.funcLastStats != nil {
		mmLastStats.mock.t.Fatalf("SupplyStatsRepoMock.LastStats mock is already set by Set")
	}

	if mmLastStats.defaultExpectation == nil {
		mmLastStats.defaultExpectation = &SupplyStatsRepoMockLastStatsExpectation{}
	}

	return mmLastStats
}

// Inspect accepts an inspector function that has same arguments as the SupplyStatsRepo.LastStats
func (mmLastStats *mSupplyStatsRepoMockLastStats) Inspect(f func()) *mSupplyStatsRepoMockLastStats {
	if mmLastStats.mock.inspectFuncLastStats != nil {
		mmLastStats.mock.t.Fatalf("Inspect function is already set for SupplyStatsRepoMock.LastStats")
	}

	mmLastStats.mock.inspectFuncLastStats = f

	return mmLastStats
}

// Return sets up results that will be returned by SupplyStatsRepo.LastStats
func (mmLastStats *mSupplyStatsRepoMockLastStats) Return(s1 SupplyStatsModel, err error) *SupplyStatsRepoMock {
	if mmLastStats.mock.funcLastStats != nil {
		mmLastStats.mock.t.Fatalf("SupplyStatsRepoMock.LastStats mock is already set by Set")
	}

	if mmLastStats.defaultExpectation == nil {
		mmLastStats.defaultExpectation = &SupplyStatsRepoMockLastStatsExpectation{mock: mmLastStats.mock}
	}
	mmLastStats.defaultExpectation.results = &SupplyStatsRepoMockLastStatsResults{s1, err}
	return mmLastStats.mock
}

//Set uses given function f to mock the SupplyStatsRepo.LastStats method
func (mmLastStats *mSupplyStatsRepoMockLastStats) Set(f func() (s1 SupplyStatsModel, err error)) *SupplyStatsRepoMock {
	if mmLastStats.defaultExpectation != nil {
		mmLastStats.mock.t.Fatalf("Default expectation is already set for the SupplyStatsRepo.LastStats method")
	}

	if len(mmLastStats.expectations) > 0 {
		mmLastStats.mock.t.Fatalf("Some expectations are already set for the SupplyStatsRepo.LastStats method")
	}

	mmLastStats.mock.funcLastStats = f
	return mmLastStats.mock
}

// LastStats implements SupplyStatsRepo
func (mmLastStats *SupplyStatsRepoMock) LastStats() (s1 SupplyStatsModel, err error) {
	mm_atomic.AddUint64(&mmLastStats.beforeLastStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmLastStats.afterLastStatsCounter, 1)

	if mmLastStats.inspectFuncLastStats != nil {
		mmLastStats.inspectFuncLastStats()
	}

	if mmLastStats.LastStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLastStats.LastStatsMock.defaultExpectation.Counter, 1)

		mm_results := mmLastStats.LastStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmLastStats.t.Fatal("No results are set for the SupplyStatsRepoMock.LastStats")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLastStats.funcLastStats != nil {
		return mmLastStats.funcLastStats()
	}
	mmLastStats.t.Fatalf("Unexpected call to SupplyStatsRepoMock.LastStats.")
	return
}

// LastStatsAfterCounter returns a count of finished SupplyStatsRepoMock.LastStats invocations
func (mmLastStats *SupplyStatsRepoMock) LastStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastStats.afterLastStatsCounter)
}

// LastStatsBeforeCounter returns a count of SupplyStatsRepoMock.LastStats invocations
func (mmLastStats *SupplyStatsRepoMock) LastStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastStats.beforeLastStatsCounter)
}

// MinimockLastStatsDone returns true if the count of the LastStats invocations corresponds
// the number of defined expectations
func (m *SupplyStatsRepoMock) MinimockLastStatsDone() bool {
	for _, e := range m.LastStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastStats != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockLastStatsInspect logs each unmet expectation
func (m *SupplyStatsRepoMock) MinimockLastStatsInspect() {
	for _, e := range m.LastStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SupplyStatsRepoMock.LastStats")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		m.t.Error("Expected call to SupplyStatsRepoMock.LastStats")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastStats != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		m.t.Error("Expected call to SupplyStatsRepoMock.LastStats")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SupplyStatsRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCountStatsInspect()

		m.MinimockInsertStatsInspect()

		m.MinimockLastStatsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SupplyStatsRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SupplyStatsRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCountStatsDone() &&
		m.MinimockInsertStatsDone() &&
		m.MinimockLastStatsDone()
}
