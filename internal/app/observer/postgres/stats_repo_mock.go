package postgres

// Code generated by http://github.com/gojuno/minimock (2.1.9). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// StatsRepoMock implements StatsRepo
type StatsRepoMock struct {
	t minimock.Tester

	funcCountStats          func() (s1 StatsModel, err error)
	inspectFuncCountStats   func()
	afterCountStatsCounter  uint64
	beforeCountStatsCounter uint64
	CountStatsMock          mStatsRepoMockCountStats

	funcInsertStats          func(s1 StatsModel) (err error)
	inspectFuncInsertStats   func(s1 StatsModel)
	afterInsertStatsCounter  uint64
	beforeInsertStatsCounter uint64
	InsertStatsMock          mStatsRepoMockInsertStats

	funcLastStats          func() (s1 StatsModel, err error)
	inspectFuncLastStats   func()
	afterLastStatsCounter  uint64
	beforeLastStatsCounter uint64
	LastStatsMock          mStatsRepoMockLastStats
}

// NewStatsRepoMock returns a mock for StatsRepo
func NewStatsRepoMock(t minimock.Tester) *StatsRepoMock {
	m := &StatsRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CountStatsMock = mStatsRepoMockCountStats{mock: m}

	m.InsertStatsMock = mStatsRepoMockInsertStats{mock: m}
	m.InsertStatsMock.callArgs = []*StatsRepoMockInsertStatsParams{}

	m.LastStatsMock = mStatsRepoMockLastStats{mock: m}

	return m
}

type mStatsRepoMockCountStats struct {
	mock               *StatsRepoMock
	defaultExpectation *StatsRepoMockCountStatsExpectation
	expectations       []*StatsRepoMockCountStatsExpectation
}

// StatsRepoMockCountStatsExpectation specifies expectation struct of the StatsRepo.CountStats
type StatsRepoMockCountStatsExpectation struct {
	mock *StatsRepoMock

	results *StatsRepoMockCountStatsResults
	Counter uint64
}

// StatsRepoMockCountStatsResults contains results of the StatsRepo.CountStats
type StatsRepoMockCountStatsResults struct {
	s1  StatsModel
	err error
}

// Expect sets up expected params for StatsRepo.CountStats
func (mmCountStats *mStatsRepoMockCountStats) Expect() *mStatsRepoMockCountStats {
	if mmCountStats.mock.funcCountStats != nil {
		mmCountStats.mock.t.Fatalf("StatsRepoMock.CountStats mock is already set by Set")
	}

	if mmCountStats.defaultExpectation == nil {
		mmCountStats.defaultExpectation = &StatsRepoMockCountStatsExpectation{}
	}

	return mmCountStats
}

// Inspect accepts an inspector function that has same arguments as the StatsRepo.CountStats
func (mmCountStats *mStatsRepoMockCountStats) Inspect(f func()) *mStatsRepoMockCountStats {
	if mmCountStats.mock.inspectFuncCountStats != nil {
		mmCountStats.mock.t.Fatalf("Inspect function is already set for StatsRepoMock.CountStats")
	}

	mmCountStats.mock.inspectFuncCountStats = f

	return mmCountStats
}

// Return sets up results that will be returned by StatsRepo.CountStats
func (mmCountStats *mStatsRepoMockCountStats) Return(s1 StatsModel, err error) *StatsRepoMock {
	if mmCountStats.mock.funcCountStats != nil {
		mmCountStats.mock.t.Fatalf("StatsRepoMock.CountStats mock is already set by Set")
	}

	if mmCountStats.defaultExpectation == nil {
		mmCountStats.defaultExpectation = &StatsRepoMockCountStatsExpectation{mock: mmCountStats.mock}
	}
	mmCountStats.defaultExpectation.results = &StatsRepoMockCountStatsResults{s1, err}
	return mmCountStats.mock
}

//Set uses given function f to mock the StatsRepo.CountStats method
func (mmCountStats *mStatsRepoMockCountStats) Set(f func() (s1 StatsModel, err error)) *StatsRepoMock {
	if mmCountStats.defaultExpectation != nil {
		mmCountStats.mock.t.Fatalf("Default expectation is already set for the StatsRepo.CountStats method")
	}

	if len(mmCountStats.expectations) > 0 {
		mmCountStats.mock.t.Fatalf("Some expectations are already set for the StatsRepo.CountStats method")
	}

	mmCountStats.mock.funcCountStats = f
	return mmCountStats.mock
}

// CountStats implements StatsRepo
func (mmCountStats *StatsRepoMock) CountStats() (s1 StatsModel, err error) {
	mm_atomic.AddUint64(&mmCountStats.beforeCountStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmCountStats.afterCountStatsCounter, 1)

	if mmCountStats.inspectFuncCountStats != nil {
		mmCountStats.inspectFuncCountStats()
	}

	if mmCountStats.CountStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCountStats.CountStatsMock.defaultExpectation.Counter, 1)

		mm_results := mmCountStats.CountStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmCountStats.t.Fatal("No results are set for the StatsRepoMock.CountStats")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCountStats.funcCountStats != nil {
		return mmCountStats.funcCountStats()
	}
	mmCountStats.t.Fatalf("Unexpected call to StatsRepoMock.CountStats.")
	return
}

// CountStatsAfterCounter returns a count of finished StatsRepoMock.CountStats invocations
func (mmCountStats *StatsRepoMock) CountStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountStats.afterCountStatsCounter)
}

// CountStatsBeforeCounter returns a count of StatsRepoMock.CountStats invocations
func (mmCountStats *StatsRepoMock) CountStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountStats.beforeCountStatsCounter)
}

// MinimockCountStatsDone returns true if the count of the CountStats invocations corresponds
// the number of defined expectations
func (m *StatsRepoMock) MinimockCountStatsDone() bool {
	for _, e := range m.CountStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CountStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountStats != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCountStatsInspect logs each unmet expectation
func (m *StatsRepoMock) MinimockCountStatsInspect() {
	for _, e := range m.CountStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StatsRepoMock.CountStats")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CountStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		m.t.Error("Expected call to StatsRepoMock.CountStats")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountStats != nil && mm_atomic.LoadUint64(&m.afterCountStatsCounter) < 1 {
		m.t.Error("Expected call to StatsRepoMock.CountStats")
	}
}

type mStatsRepoMockInsertStats struct {
	mock               *StatsRepoMock
	defaultExpectation *StatsRepoMockInsertStatsExpectation
	expectations       []*StatsRepoMockInsertStatsExpectation

	callArgs []*StatsRepoMockInsertStatsParams
	mutex    sync.RWMutex
}

// StatsRepoMockInsertStatsExpectation specifies expectation struct of the StatsRepo.InsertStats
type StatsRepoMockInsertStatsExpectation struct {
	mock    *StatsRepoMock
	params  *StatsRepoMockInsertStatsParams
	results *StatsRepoMockInsertStatsResults
	Counter uint64
}

// StatsRepoMockInsertStatsParams contains parameters of the StatsRepo.InsertStats
type StatsRepoMockInsertStatsParams struct {
	s1 StatsModel
}

// StatsRepoMockInsertStatsResults contains results of the StatsRepo.InsertStats
type StatsRepoMockInsertStatsResults struct {
	err error
}

// Expect sets up expected params for StatsRepo.InsertStats
func (mmInsertStats *mStatsRepoMockInsertStats) Expect(s1 StatsModel) *mStatsRepoMockInsertStats {
	if mmInsertStats.mock.funcInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("StatsRepoMock.InsertStats mock is already set by Set")
	}

	if mmInsertStats.defaultExpectation == nil {
		mmInsertStats.defaultExpectation = &StatsRepoMockInsertStatsExpectation{}
	}

	mmInsertStats.defaultExpectation.params = &StatsRepoMockInsertStatsParams{s1}
	for _, e := range mmInsertStats.expectations {
		if minimock.Equal(e.params, mmInsertStats.defaultExpectation.params) {
			mmInsertStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertStats.defaultExpectation.params)
		}
	}

	return mmInsertStats
}

// Inspect accepts an inspector function that has same arguments as the StatsRepo.InsertStats
func (mmInsertStats *mStatsRepoMockInsertStats) Inspect(f func(s1 StatsModel)) *mStatsRepoMockInsertStats {
	if mmInsertStats.mock.inspectFuncInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("Inspect function is already set for StatsRepoMock.InsertStats")
	}

	mmInsertStats.mock.inspectFuncInsertStats = f

	return mmInsertStats
}

// Return sets up results that will be returned by StatsRepo.InsertStats
func (mmInsertStats *mStatsRepoMockInsertStats) Return(err error) *StatsRepoMock {
	if mmInsertStats.mock.funcInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("StatsRepoMock.InsertStats mock is already set by Set")
	}

	if mmInsertStats.defaultExpectation == nil {
		mmInsertStats.defaultExpectation = &StatsRepoMockInsertStatsExpectation{mock: mmInsertStats.mock}
	}
	mmInsertStats.defaultExpectation.results = &StatsRepoMockInsertStatsResults{err}
	return mmInsertStats.mock
}

//Set uses given function f to mock the StatsRepo.InsertStats method
func (mmInsertStats *mStatsRepoMockInsertStats) Set(f func(s1 StatsModel) (err error)) *StatsRepoMock {
	if mmInsertStats.defaultExpectation != nil {
		mmInsertStats.mock.t.Fatalf("Default expectation is already set for the StatsRepo.InsertStats method")
	}

	if len(mmInsertStats.expectations) > 0 {
		mmInsertStats.mock.t.Fatalf("Some expectations are already set for the StatsRepo.InsertStats method")
	}

	mmInsertStats.mock.funcInsertStats = f
	return mmInsertStats.mock
}

// When sets expectation for the StatsRepo.InsertStats which will trigger the result defined by the following
// Then helper
func (mmInsertStats *mStatsRepoMockInsertStats) When(s1 StatsModel) *StatsRepoMockInsertStatsExpectation {
	if mmInsertStats.mock.funcInsertStats != nil {
		mmInsertStats.mock.t.Fatalf("StatsRepoMock.InsertStats mock is already set by Set")
	}

	expectation := &StatsRepoMockInsertStatsExpectation{
		mock:   mmInsertStats.mock,
		params: &StatsRepoMockInsertStatsParams{s1},
	}
	mmInsertStats.expectations = append(mmInsertStats.expectations, expectation)
	return expectation
}

// Then sets up StatsRepo.InsertStats return parameters for the expectation previously defined by the When method
func (e *StatsRepoMockInsertStatsExpectation) Then(err error) *StatsRepoMock {
	e.results = &StatsRepoMockInsertStatsResults{err}
	return e.mock
}

// InsertStats implements StatsRepo
func (mmInsertStats *StatsRepoMock) InsertStats(s1 StatsModel) (err error) {
	mm_atomic.AddUint64(&mmInsertStats.beforeInsertStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertStats.afterInsertStatsCounter, 1)

	if mmInsertStats.inspectFuncInsertStats != nil {
		mmInsertStats.inspectFuncInsertStats(s1)
	}

	mm_params := &StatsRepoMockInsertStatsParams{s1}

	// Record call args
	mmInsertStats.InsertStatsMock.mutex.Lock()
	mmInsertStats.InsertStatsMock.callArgs = append(mmInsertStats.InsertStatsMock.callArgs, mm_params)
	mmInsertStats.InsertStatsMock.mutex.Unlock()

	for _, e := range mmInsertStats.InsertStatsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertStats.InsertStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertStats.InsertStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertStats.InsertStatsMock.defaultExpectation.params
		mm_got := StatsRepoMockInsertStatsParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertStats.t.Errorf("StatsRepoMock.InsertStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertStats.InsertStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertStats.t.Fatal("No results are set for the StatsRepoMock.InsertStats")
		}
		return (*mm_results).err
	}
	if mmInsertStats.funcInsertStats != nil {
		return mmInsertStats.funcInsertStats(s1)
	}
	mmInsertStats.t.Fatalf("Unexpected call to StatsRepoMock.InsertStats. %v", s1)
	return
}

// InsertStatsAfterCounter returns a count of finished StatsRepoMock.InsertStats invocations
func (mmInsertStats *StatsRepoMock) InsertStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertStats.afterInsertStatsCounter)
}

// InsertStatsBeforeCounter returns a count of StatsRepoMock.InsertStats invocations
func (mmInsertStats *StatsRepoMock) InsertStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertStats.beforeInsertStatsCounter)
}

// Calls returns a list of arguments used in each call to StatsRepoMock.InsertStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertStats *mStatsRepoMockInsertStats) Calls() []*StatsRepoMockInsertStatsParams {
	mmInsertStats.mutex.RLock()

	argCopy := make([]*StatsRepoMockInsertStatsParams, len(mmInsertStats.callArgs))
	copy(argCopy, mmInsertStats.callArgs)

	mmInsertStats.mutex.RUnlock()

	return argCopy
}

// MinimockInsertStatsDone returns true if the count of the InsertStats invocations corresponds
// the number of defined expectations
func (m *StatsRepoMock) MinimockInsertStatsDone() bool {
	for _, e := range m.InsertStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertStats != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertStatsInspect logs each unmet expectation
func (m *StatsRepoMock) MinimockInsertStatsInspect() {
	for _, e := range m.InsertStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatsRepoMock.InsertStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		if m.InsertStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StatsRepoMock.InsertStats")
		} else {
			m.t.Errorf("Expected call to StatsRepoMock.InsertStats with params: %#v", *m.InsertStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertStats != nil && mm_atomic.LoadUint64(&m.afterInsertStatsCounter) < 1 {
		m.t.Error("Expected call to StatsRepoMock.InsertStats")
	}
}

type mStatsRepoMockLastStats struct {
	mock               *StatsRepoMock
	defaultExpectation *StatsRepoMockLastStatsExpectation
	expectations       []*StatsRepoMockLastStatsExpectation
}

// StatsRepoMockLastStatsExpectation specifies expectation struct of the StatsRepo.LastStats
type StatsRepoMockLastStatsExpectation struct {
	mock *StatsRepoMock

	results *StatsRepoMockLastStatsResults
	Counter uint64
}

// StatsRepoMockLastStatsResults contains results of the StatsRepo.LastStats
type StatsRepoMockLastStatsResults struct {
	s1  StatsModel
	err error
}

// Expect sets up expected params for StatsRepo.LastStats
func (mmLastStats *mStatsRepoMockLastStats) Expect() *mStatsRepoMockLastStats {
	if mmLastStats.mock.funcLastStats != nil {
		mmLastStats.mock.t.Fatalf("StatsRepoMock.LastStats mock is already set by Set")
	}

	if mmLastStats.defaultExpectation == nil {
		mmLastStats.defaultExpectation = &StatsRepoMockLastStatsExpectation{}
	}

	return mmLastStats
}

// Inspect accepts an inspector function that has same arguments as the StatsRepo.LastStats
func (mmLastStats *mStatsRepoMockLastStats) Inspect(f func()) *mStatsRepoMockLastStats {
	if mmLastStats.mock.inspectFuncLastStats != nil {
		mmLastStats.mock.t.Fatalf("Inspect function is already set for StatsRepoMock.LastStats")
	}

	mmLastStats.mock.inspectFuncLastStats = f

	return mmLastStats
}

// Return sets up results that will be returned by StatsRepo.LastStats
func (mmLastStats *mStatsRepoMockLastStats) Return(s1 StatsModel, err error) *StatsRepoMock {
	if mmLastStats.mock.funcLastStats != nil {
		mmLastStats.mock.t.Fatalf("StatsRepoMock.LastStats mock is already set by Set")
	}

	if mmLastStats.defaultExpectation == nil {
		mmLastStats.defaultExpectation = &StatsRepoMockLastStatsExpectation{mock: mmLastStats.mock}
	}
	mmLastStats.defaultExpectation.results = &StatsRepoMockLastStatsResults{s1, err}
	return mmLastStats.mock
}

//Set uses given function f to mock the StatsRepo.LastStats method
func (mmLastStats *mStatsRepoMockLastStats) Set(f func() (s1 StatsModel, err error)) *StatsRepoMock {
	if mmLastStats.defaultExpectation != nil {
		mmLastStats.mock.t.Fatalf("Default expectation is already set for the StatsRepo.LastStats method")
	}

	if len(mmLastStats.expectations) > 0 {
		mmLastStats.mock.t.Fatalf("Some expectations are already set for the StatsRepo.LastStats method")
	}

	mmLastStats.mock.funcLastStats = f
	return mmLastStats.mock
}

// LastStats implements StatsRepo
func (mmLastStats *StatsRepoMock) LastStats() (s1 StatsModel, err error) {
	mm_atomic.AddUint64(&mmLastStats.beforeLastStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmLastStats.afterLastStatsCounter, 1)

	if mmLastStats.inspectFuncLastStats != nil {
		mmLastStats.inspectFuncLastStats()
	}

	if mmLastStats.LastStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLastStats.LastStatsMock.defaultExpectation.Counter, 1)

		mm_results := mmLastStats.LastStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmLastStats.t.Fatal("No results are set for the StatsRepoMock.LastStats")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLastStats.funcLastStats != nil {
		return mmLastStats.funcLastStats()
	}
	mmLastStats.t.Fatalf("Unexpected call to StatsRepoMock.LastStats.")
	return
}

// LastStatsAfterCounter returns a count of finished StatsRepoMock.LastStats invocations
func (mmLastStats *StatsRepoMock) LastStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastStats.afterLastStatsCounter)
}

// LastStatsBeforeCounter returns a count of StatsRepoMock.LastStats invocations
func (mmLastStats *StatsRepoMock) LastStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastStats.beforeLastStatsCounter)
}

// MinimockLastStatsDone returns true if the count of the LastStats invocations corresponds
// the number of defined expectations
func (m *StatsRepoMock) MinimockLastStatsDone() bool {
	for _, e := range m.LastStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastStats != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockLastStatsInspect logs each unmet expectation
func (m *StatsRepoMock) MinimockLastStatsInspect() {
	for _, e := range m.LastStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StatsRepoMock.LastStats")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		m.t.Error("Expected call to StatsRepoMock.LastStats")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastStats != nil && mm_atomic.LoadUint64(&m.afterLastStatsCounter) < 1 {
		m.t.Error("Expected call to StatsRepoMock.LastStats")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StatsRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCountStatsInspect()

		m.MinimockInsertStatsInspect()

		m.MinimockLastStatsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StatsRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StatsRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCountStatsDone() &&
		m.MinimockInsertStatsDone() &&
		m.MinimockLastStatsDone()
}
