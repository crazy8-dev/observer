// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
	"net/http"
)

// DefinitionsResponsesBalanceYaml defines model for definitions-responses-balance-yaml.
type DefinitionsResponsesBalanceYaml struct {
	AccountReference string `json:"accountReference"`
	Balance          string `json:"balance"`
	Deposits         *[]struct {
		AmountOnHold    string  `json:"amountOnHold"`
		AvailableAmount string  `json:"availableAmount"`
		EthTxHash       string  `json:"ethTxHash"`
		HoldReleaseDate int64   `json:"holdReleaseDate"`
		Index           float32 `json:"index"`
		NextRelease     *struct {
			Amount    string `json:"amount"`
			Timestamp int64  `json:"timestamp"`
		} `json:"nextRelease,omitempty"`
		Reference      *string `json:"reference,omitempty"`
		ReleaseEndDate int64   `json:"releaseEndDate"`
		ReleasedAmount string  `json:"releasedAmount"`
		Status         string  `json:"status"`
		Timestamp      int64   `json:"timestamp"`
	} `json:"deposits,omitempty"`
	MigrationAddress *string `json:"migrationAddress,omitempty"`
	WalletReference  string  `json:"walletReference"`
}

// DefinitionsResponsesCoinsYaml defines model for definitions-responses-coins-yaml.
type DefinitionsResponsesCoinsYaml struct {
	CirculatingSupply float32 `json:"circulatingSupply"`
	MaxSupply         float32 `json:"maxSupply"`
	TotalSupply       float32 `json:"totalSupply"`
}

// DefinitionsResponsesCoinsCirculatingYaml defines model for definitions-responses-coinsCirculating-yaml.
type DefinitionsResponsesCoinsCirculatingYaml struct {
	CirculatingSupply float32 `json:"circulatingSupply"`
}

// DefinitionsResponsesCoinsMaxYaml defines model for definitions-responses-coinsMax-yaml.
type DefinitionsResponsesCoinsMaxYaml struct {
	MaxSupply float32 `json:"maxSupply"`
}

// DefinitionsResponsesCoinsTotalYaml defines model for definitions-responses-coinsTotal-yaml.
type DefinitionsResponsesCoinsTotalYaml struct {
	TotalSupply float32 `json:"totalSupply"`
}

// DefinitionsResponsesFeeYaml defines model for definitions-responses-fee-yaml.
type DefinitionsResponsesFeeYaml struct {
	Fee string `json:"fee"`
}

// DefinitionsResponsesInvalidAmountYaml defines model for definitions-responses-invalidAmount-yaml.
type DefinitionsResponsesInvalidAmountYaml struct {
	Error []string `json:"error"`
}

// DefinitionsResponsesInvalidReferenceYaml defines model for definitions-responses-invalidReference-yaml.
type DefinitionsResponsesInvalidReferenceYaml struct {
	Error []string `json:"error"`
}

// DefinitionsResponsesInvalidTransactionIdYaml defines model for definitions-responses-invalidTransactionId-yaml.
type DefinitionsResponsesInvalidTransactionIdYaml struct {
	Error []string `json:"error"`
}

// DefinitionsResponsesInvalidTransactionListParametersYaml defines model for definitions-responses-invalidTransactionListParameters-yaml.
type DefinitionsResponsesInvalidTransactionListParametersYaml struct {
	Error []string `json:"error"`
}

// DefinitionsResponsesMemberTransactionsYaml defines model for definitions-responses-member-transactions-yaml.
type DefinitionsResponsesMemberTransactionsYaml []interface{}

// DefinitionsResponsesMemberBalanceYaml defines model for definitions-responses-memberBalance-yaml.
type DefinitionsResponsesMemberBalanceYaml struct {
	Balance string `json:"balance"`
}

// DefinitionsResponsesNotificationInfoYaml defines model for definitions-responses-notificationInfo-yaml.
type DefinitionsResponsesNotificationInfoYaml struct {
	Notification string `json:"notification"`
}

// DefinitionsResponsesTransactionYaml defines model for definitions-responses-transaction-yaml.
type DefinitionsResponsesTransactionYaml interface{}

// DefinitionsResponsesTransactionsYaml defines model for definitions-responses-transactions-yaml.
type DefinitionsResponsesTransactionsYaml []interface{}

// Migration defines model for migration.
type Migration struct {
	// Embedded struct due to allOf(#/components/schemas/transaction)
	Transaction
	// Embedded fields due to inline allOf schema
	FromMemberReference *string      `json:"fromMemberReference,omitempty"`
	ToDepositReference  *string      `json:"toDepositReference,omitempty"`
	ToMemberReference   *string      `json:"toMemberReference,omitempty"`
	Type                *interface{} `json:"type,omitempty"`
}

// Release defines model for release.
type Release struct {
	// Embedded struct due to allOf(#/components/schemas/transaction)
	Transaction
	// Embedded fields due to inline allOf schema
	FromDepositReference *string      `json:"fromDepositReference,omitempty"`
	ToMemberReference    *string      `json:"toMemberReference,omitempty"`
	Type                 *interface{} `json:"type,omitempty"`
}

// Transaction defines model for transaction.
type Transaction struct {
	Amount      string  `json:"amount"`
	Fee         string  `json:"fee"`
	Index       float32 `json:"index"`
	PulseNumber int64   `json:"pulseNumber"`
	Status      string  `json:"status"`
	Timestamp   float32 `json:"timestamp"`
	TxID        string  `json:"txID"`
	Type        string  `json:"type"`
}

// Transfer defines model for transfer.
type Transfer struct {
	// Embedded struct due to allOf(#/components/schemas/transaction)
	Transaction
	// Embedded fields due to inline allOf schema
	FromMemberReference *string      `json:"fromMemberReference,omitempty"`
	ToMemberReference   *string      `json:"toMemberReference,omitempty"`
	Type                *interface{} `json:"type,omitempty"`
}

// MemberTransactionsParams defines parameters for MemberTransactions.
type MemberTransactionsParams struct {

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the transaction from which to start the list. To get the list of most recent transactions, do not specify.
	Index *float32 `json:"index,omitempty"`

	// Chronological `direction` of the transaction list starting from a given `index`:
	//
	//   * `before` — get transactions that chronologically preceed a transaction with a given `index`;
	//   * `after` — get transactions that chronologically follow a transaction with a given `index`.
	Direction *string `json:"direction,omitempty"`

	// Transaction type:
	//
	// * `transfer` - transactions to/from to member,
	// * `migration` - transactions only to member's deposits,
	// * `release` - transactions only from member's deposits to member's account.
	Type *string `json:"type,omitempty"`

	// Transaction status:
	//
	// * `registered` — transfer request is registered;
	// * `sent` — transfer of funds from the sender is finalized;
	// * `received` — transfer of funds to the receiver is finalized.
	// * `failed` — transfer of funds is finalized with an error, e.g., in case of insufficient balance.
	Status *string `json:"status,omitempty"`
}

// TransactionsSearchParams defines parameters for TransactionsSearch.
type TransactionsSearchParams struct {

	// Value of `txID`, `fromMemberReference`, `toMemberReference` or `pulseNumber` by which to search (filter) transactions.
	//
	// Note: since path parameters must be valid parts of URL, the `:` after `insolar` in references and IDs is to be replaced with `%3A` in accordance with the HTML URL encoding.
	Value *string `json:"value,omitempty"`

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the transaction from which to start the list. To get the list of most recent transactions, do not specify.
	Index *float32 `json:"index,omitempty"`

	// Chronological `direction` of the transaction list starting from a given `index`:
	//
	//   * `before` — get transactions that chronologically preceed a transaction with a given `index`;
	//   * `after` — get transactions that chronologically follow a transaction with a given `index`.
	Direction *string `json:"direction,omitempty"`

	// Transaction type:
	//
	// * `transfer` - transactions to/from to member,
	// * `migration` - transactions only to member's deposits,
	// * `release` - transactions only from member's deposits to member's account.
	Type *string `json:"type,omitempty"`

	// Transaction status:
	//
	// * `registered` — transfer request is registered;
	// * `sent` — transfer of funds from the sender is finalized;
	// * `received` — transfer of funds to the receiver is finalized.
	// * `failed` — transfer of funds is finalized with an error, e.g., in case of insufficient balance.
	Status *string `json:"status,omitempty"`
}

// ClosedTransactionsParams defines parameters for ClosedTransactions.
type ClosedTransactionsParams struct {

	// Number of entries per list.
	Limit int `json:"limit"`

	// Index of the transaction from which to start the list. To get the list of most recent transactions, do not specify.
	Index *float32 `json:"index,omitempty"`

	// Chronological `direction` of the transaction list starting from a given `index`:
	//
	//   * `before` — get transactions that chronologically preceed a transaction with a given `index`;
	//   * `after` — get transactions that chronologically follow a transaction with a given `index`.
	Direction *string `json:"direction,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// fee// (GET /api/fee/{amount})
	Fee(ctx echo.Context, amount string) error
	// member// (GET /api/member/{reference})
	Member(ctx echo.Context, reference string) error
	// member balance// (GET /api/member/{reference}/balance)
	Balance(ctx echo.Context, reference string) error
	// member transactions// (GET /api/member/{reference}/transactions)
	MemberTransactions(ctx echo.Context, reference string, params MemberTransactionsParams) error
	// notification// (GET /api/notification)
	Notification(ctx echo.Context) error
	// transaction// (GET /api/transaction/{txID})
	Transaction(ctx echo.Context, txID string) error
	// transactions// (GET /api/transactions)
	TransactionsSearch(ctx echo.Context, params TransactionsSearchParams) error
	// closed transactions// (GET /api/transactions/closed)
	ClosedTransactions(ctx echo.Context, params ClosedTransactionsParams) error
	// coins// (GET /coins)
	Coins(ctx echo.Context) error
	// coins/circulating// (GET /coins/circulating)
	CoinsCirculating(ctx echo.Context) error
	// coins/max// (GET /coins/max)
	CoinsMax(ctx echo.Context) error
	// coins/total// (GET /coins/total)
	CoinsTotal(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Fee converts echo context to params.
func (w *ServerInterfaceWrapper) Fee(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "amount" -------------
	var amount string

	err = runtime.BindStyledParameter("simple", false, "amount", ctx.Param("amount"), &amount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter amount: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Fee(ctx, amount)
	return err
}

// Member converts echo context to params.
func (w *ServerInterfaceWrapper) Member(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reference" -------------
	var reference string

	err = runtime.BindStyledParameter("simple", false, "reference", ctx.Param("reference"), &reference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reference: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Member(ctx, reference)
	return err
}

// Balance converts echo context to params.
func (w *ServerInterfaceWrapper) Balance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reference" -------------
	var reference string

	err = runtime.BindStyledParameter("simple", false, "reference", ctx.Param("reference"), &reference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reference: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Balance(ctx, reference)
	return err
}

// MemberTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) MemberTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reference" -------------
	var reference string

	err = runtime.BindStyledParameter("simple", false, "reference", ctx.Param("reference"), &reference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reference: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params MemberTransactionsParams
	// ------------- Required query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument limit is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------
	if paramValue := ctx.QueryParam("index"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------
	if paramValue := ctx.QueryParam("direction"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := ctx.QueryParam("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := ctx.QueryParam("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MemberTransactions(ctx, reference, params)
	return err
}

// Notification converts echo context to params.
func (w *ServerInterfaceWrapper) Notification(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Notification(ctx)
	return err
}

// Transaction converts echo context to params.
func (w *ServerInterfaceWrapper) Transaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txID" -------------
	var txID string

	err = runtime.BindStyledParameter("simple", false, "txID", ctx.Param("txID"), &txID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Transaction(ctx, txID)
	return err
}

// TransactionsSearch converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionsSearch(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionsSearchParams
	// ------------- Optional query parameter "value" -------------
	if paramValue := ctx.QueryParam("value"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "value", ctx.QueryParams(), &params.Value)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter value: %s", err))
	}

	// ------------- Required query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument limit is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------
	if paramValue := ctx.QueryParam("index"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------
	if paramValue := ctx.QueryParam("direction"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := ctx.QueryParam("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "status" -------------
	if paramValue := ctx.QueryParam("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionsSearch(ctx, params)
	return err
}

// ClosedTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) ClosedTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ClosedTransactionsParams
	// ------------- Required query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument limit is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "index" -------------
	if paramValue := ctx.QueryParam("index"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "index", ctx.QueryParams(), &params.Index)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter index: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------
	if paramValue := ctx.QueryParam("direction"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ClosedTransactions(ctx, params)
	return err
}

// Coins converts echo context to params.
func (w *ServerInterfaceWrapper) Coins(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Coins(ctx)
	return err
}

// CoinsCirculating converts echo context to params.
func (w *ServerInterfaceWrapper) CoinsCirculating(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CoinsCirculating(ctx)
	return err
}

// CoinsMax converts echo context to params.
func (w *ServerInterfaceWrapper) CoinsMax(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CoinsMax(ctx)
	return err
}

// CoinsTotal converts echo context to params.
func (w *ServerInterfaceWrapper) CoinsTotal(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CoinsTotal(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/api/fee/:amount", wrapper.Fee)
	router.GET("/api/member/:reference", wrapper.Member)
	router.GET("/api/member/:reference/balance", wrapper.Balance)
	router.GET("/api/member/:reference/transactions", wrapper.MemberTransactions)
	router.GET("/api/notification", wrapper.Notification)
	router.GET("/api/transaction/:txID", wrapper.Transaction)
	router.GET("/api/transactions", wrapper.TransactionsSearch)
	router.GET("/api/transactions/closed", wrapper.ClosedTransactions)
	router.GET("/coins", wrapper.Coins)
	router.GET("/coins/circulating", wrapper.CoinsCirculating)
	router.GET("/coins/max", wrapper.CoinsMax)
	router.GET("/coins/total", wrapper.CoinsTotal)

}

